"Response ID","Did you take part in one of the previous decompiler surveys? [Decompiler Survey 1 - October 2020]","Did you take part in one of the previous decompiler surveys? [Decompiler Survey 2 - April 2021]","How much time (approx.) did you spend working with C code? (Development, Reviews, Learning, ...)","How much time did you spend reversing executables before?","In this part, we will show you code snippets that are decompiled with different decompilers.  At the end of the survey, we will disclose which decompilers were used and their exact versions.",".tab {   overflow: hidden;   border: 2px solid #ccc;   background-color: #f1f1f1; }  /* Style the buttons that are used to open the tab content */ .tab button {   background-color: inherit;   color:black;   float: left;   border: none;   outline: none;   cursor: pointer;   padding: 14px 16px;   transition: 0.3s; }  /* Change background color of buttons on hover */ .tab button:hover {   background-color: #ddd; }  /* Create an active/current tablink class */ .tab button.active {   background-color: #ccc; }  /* Style the tab content */ .tabcontent {   display: none;   padding: 0;   border: 1px solid #ccc;   border-top: none; }   CloveCuminChilli               ","Please rank the decompiled code presented. [Rank 1]","Please rank the decompiled code presented. [Rank 2]","Please rank the decompiled code presented. [Rank 3]","Which aspects in the decompiled codes above is especially favorable to you?","Which aspects of the presented decompiled functions do you deem unhelpful?",".tab {     overflow: hidden;     border: 1px solid #ccc;     background-color: #f1f1f1;   }      /* Style the buttons that are used to open the tab content */   .tab button {     background-color: inherit;     color:black;     float: left;     border: none;     outline: none;     cursor: pointer;     padding: 14px 16px;     transition: 0.3s;   }      /* Change background color of buttons on hover */   .tab button:hover {     background-color: #ddd;   }      /* Create an active/current tablink class */   .tab button.active {     background-color: #ccc;   }      /* Style the tab content */   .tabcontent {     display: none;     padding: 0;     border: 1px solid #ccc;     border-top: none;   }   Sample 1Sample 2Sample 3Sample 4                    ","Please rank the decompiled code presented. [Rank 1]","Please rank the decompiled code presented. [Rank 2]","Please rank the decompiled code presented. [Rank 3]","Please rank the decompiled code presented. [Rank 4]","Which aspects in the decompiled codes above is especially favorable to you?","Which aspects of the presented decompiled functions do you deem unhelpful or hamper your understanding of the code?","In this part, we will show you short code snippets that represent the same code but are restructured differently. The goal is to find a way to establish a baseline on user preference between the presented approaches.","Please consider the following two code snippets, which both represent the same semantics with a different structure.  In Snippet 1, /* Block #10 */ is copied to achieve a simplified structure, while in Snippet 2 it occurs only once.   	 		 			Snippet 1  			Snippet 2  		 		 			 			  			  			 			  			  		 	       Which structure do you prefer in general?","Now, please consider the following possible instruction sequences as replacement for /* Block #10 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #10 */? [Option 1  (1 Instruction)]","Now, please consider the following possible instruction sequences as replacement for /* Block #10 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #10 */? [Option 2  (5 Instructions)]","Now, please consider the following possible instruction sequences as replacement for /* Block #10 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #10 */? [Option 3  (15 Instructions)]","Please explain your choices. Which criteria guide your decision?","Now, please assume that /* Block #10 */ contains a more complex structure, for example the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #10 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 1 (Copying /* Block #10 */)]","Now, please assume that /* Block #10 */ contains a more complex structure, for example the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #10 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 2 (Not copying /* Block #10 */)]","Now, please assume that /* Block #10 */ contains a more complex structure, for example the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #10 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 3 (Extracting /* Block #10 */ as a function and calling it twice)]","Please explain your choice.","Please consider the following two code snippets which both represent the same semantics with a different structure.  In Snippet 1, /* Block #10 */ is copied to achieve a simplified structure while in Snippet 2 it is not.   	 		 			Snippet 1  			Snippet 2  		 		 			 			  			  			 			  			  		 	      Which structure do you prefer in general?","Now, please consider the following possible instruction sequences as replacement for /* Block #10 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #10 */? [Option 1  (1 Instruction)]","Now, please consider the following possible instruction sequences as replacement for /* Block #10 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #10 */? [Option 2  (5 Instructions)]","Now, please consider the following possible instruction sequences as replacement for /* Block #10 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #10 */? [Option 3  (15 Instructions)]","Please explain your choices. Which criteria guide your decision?","Now, please assume that /* Block #10 */ contains a more complex structure, like e.g. the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #10 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 1 (Copying /* Block #10 */)]","Now, please assume that /* Block #10 */ contains a more complex structure, like e.g. the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #10 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 2 (Not copying /* Block #10 */)]","Now, please assume that /* Block #10 */ contains a more complex structure, like e.g. the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #10 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 3 (Extracting /* Block #10 */ as a function and calling it twice)]","Please explain your choice.","Please consider the following two code snippets which both represent the same semantics with a different structure.  In Snippet 1, /* Block #4 */ is copied to achieve a simplified structure, while in Snippet 2 it occurs only once.   	 		 			Snippet 1  			Snippet 2  		 		 			 			  			  			 			  			  		 	      Which structure do you prefer in general?","Now please consider the following possible instruction sequences as replacement for /* Block #4 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #4 */? [Option 1  (1 Instruction)]","Now please consider the following possible instruction sequences as replacement for /* Block #4 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #4 */? [Option 2  (5 Instructions)]","Now please consider the following possible instruction sequences as replacement for /* Block #4 */:   	 		 			Option 1  			Option 2  			Option 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which structure do you prefer depending on the length of the instruction sequence in /* Block #4 */? [Option 3  (15 Instructions)]","Please explain your choices. Which criteria guide your decision?","Now please assume that /* Block #4 */ contains a more complex structure, like the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #4 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 1 (Copying /* Block #4 */)]","Now please assume that /* Block #4 */ contains a more complex structure, like the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #4 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 2 (Not copying /* Block #4 */)]","Now please assume that /* Block #4 */ contains a more complex structure, like the following:         Snippet 1 and Snippet 2 are structured as before. In Snippet 3, /* Block #4 */ is extracted as a function.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	      Which Snippets do you like? (Multiple choices are possible) [Snippet 3 (Extracting /* Block #4 */ as a function and calling it twice)]","Please explain your choice.","Please consider the following two code snippets.   	 		 			Snippet 1  			Snippet 2  		 		 			 			  			  			 			  			  		 	         [Which snippet do you prefer?]","Please explain your choice.","Please consider the following two code snippets.   	 		 			Snippet 1  			Snippet 2 [Which snippet do you prefer?]","Please explain your choice.","Please consider the following three code snippets.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	             [Which snippet do you prefer?]","Please explain your choice.","Please consider the following three code snippets.   	 		 			Snippet 1  			Snippet 2  			Snippet 3  		 		 			 			  			  			 			  			  			 			  			  		 	             [Which snippet do you prefer?]","Please explain your choice.","Please consider the following code snippets which all represent the same semantics and rank them from your favourite to least favourite.  Snippet 1:     Snippet 2:      Snippet 3:     [Rank 1]","Please consider the following code snippets which all represent the same semantics and rank them from your favourite to least favourite.  Snippet 1:     Snippet 2:      Snippet 3:     [Rank 2]","Please consider the following code snippets which all represent the same semantics and rank them from your favourite to least favourite.  Snippet 1:     Snippet 2:      Snippet 3:     [Rank 3]","Please explain your choice.","Please consider the following code snippets which all represent the same code and rank them from your favourite to least favourite.     Snippet 1:     Snippet 2:      Snippet 3:      Snippet 4:     [Rank 1]","Please consider the following code snippets which all represent the same code and rank them from your favourite to least favourite.     Snippet 1:     Snippet 2:      Snippet 3:      Snippet 4:     [Rank 2]","Please consider the following code snippets which all represent the same code and rank them from your favourite to least favourite.     Snippet 1:     Snippet 2:      Snippet 3:      Snippet 4:     [Rank 3]","Please consider the following code snippets which all represent the same code and rank them from your favourite to least favourite.     Snippet 1:     Snippet 2:      Snippet 3:      Snippet 4:     [Rank 4]","Please explain your choice.","Thank you very much for getting this far and also for participating in any previous surveys! This is very likely to be our last decompiler survey for now.  If you would like to leave us any feedback about the survey, please use the lines below to help us improve ourselves.","Total time","Group time: Assesment","Question time: lastsurvey","Question time: c","Question time: reversing","Group time: Decompiler Comparison","Question time: Comp","Question time: decompiler","Question time: ranking","Question time: positive","Question time: negative","Group time: Comparison Logic","Question time: decompiler","Question time: ranking","Question time: positive","Question time: negative","Group time: Measurement Part","Question time: Measure0","Group time: Copy Instructions If-Else Construct","Question time: CopySimple","Question time: ConditionIfElseInstr","Question time: ConditionIfElseFree","Question time: ConditionIfElseFunc","Question time: ConditionIfElseFFree","Group time: Copy Instructions Multiple Exit for Loops","Question time: CopyMultExit","Question time: ConditionMExitInstr","Question time: ConditionMExitFree","Question time: ConditionMExitFunc","Question time: ConditionMExitFFree","Group time: Copy Instructions Multiple Entry for Loops","Question time: CopyMultEntry","Question time: ConditionMEntryInstr","Question time: ConditionMEntryFree","Question time: ConditionMEntryFunc","Question time: ConditionMEntryFFree","Group time: Switch","Question time: SwitchCases2Snippets","Question time: Switch2Free","Question time: SwitchCases5Snippets","Question time: Switch5Free","Question time: SwitchCase2dSnippets","Question time: Switch2DFree","Question time: SwitchCase5dSnippets","Question time: Switch5DFree","Group time: Conditions","Question time: ConditionSnippets","Question time: ConditionFree","Group time: For-Loops","Question time: ForLoopSnippets","Question time: ForLoopFree","Group time: Feedback","Question time: feedback"
"1","Yes","No","Several days","A few hours","","","Chilli","Clove","Cumin","switch case helps understanding conditions more easily","hard to follow the heavily nested if/else, cumin with many unnecessary variables","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","the length of the structure matters, but the main reason to include it not twice is the extra step it adds to understanding which configurations use the specified paths ","No","No","Yes","by declaring a function the multiple calls are easier to read than just including the code multiple times","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","only one return statements helps to understand the cfg better","No","Yes","Yes","declaring the duplicate code in a function looks cleaner. multiple return statements require an extra look","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","it reduces the while loop to one block which helps understanding it faster","No","No","Yes","function identifies the cide block as a consistent piece that can be understood on its own without the need of identifying duplicate code","Snippet 1","for snippet 2 it's not clear whether it's possible to enter multiple if conditions","Snippet 1","for snippet 2 it's not clear whether it's possible to enter multiple if conditions","Snippet 1","switch case is easy to read and default condition remains the same during growth of switch cases","Snippet 1","switch case doesn't need to be nested and the default condition remains slim","Snippet 1","Snippet 3","Snippet 2","snippet 2 doesn't introduce unnecessary variables ot if statements","Snippet 2","Snippet 1","Snippet 3","Snippet 4","the update on the while loops variable seems the most understable","some preferences don't necessarily only relate to the mainly investigated issue of the page
","3871.59","42.03","","","","385.75","","","","","","","","","","","10.34","","715.7","","","","","","905.84","","","","","","804.25","","","","","","256.69","","","","","","","","","119.3","","","499.93","","","131.76",""
"3","No","Yes","On a regular basis","On a regular basis","","","Chilli","Clove","Cumin","The switch-statement of Chilli is nice especially vs the ""                                                                 "" indentation of Cumin.
Clove is the only one that recoginizes that 's' is used as an array and not a single value.
","Chilli could have realized 0x2710 is a power of 10. Which the other decompiler did, *wink wink*.
Chilli is the only one that does not produce valid c.
Cumin for some reason does not display the string in scanf and has redundant else branches increasing indentation.","","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","At some scoping levels duplicating a ret, or a jump to the epilog seems worthit, otherwise it depends on how much code is around it.
A return statement inside of a while-statement is often confusing and in the given example the scope-depth is manageable, so i'd vote for no duplication.

","No","Yes","No","Introducing _inline_ functions complicates the programm which i am not a fan of.
In this case, as block#10 containes a return-statement, I feel that it should always be at the bottom, so that the control flow is easier to read.
Ghidra often uses the 4th option of using a goto, more or less combining the 'simpler' scoping without copying. But gotos can also be confusing.","","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","A return statement inside of a while-statement I generally find confusing. In this case the scope-depth seems to be quite low and thus I would avoid copying in all cases.
If the scoping depth is really high, or there is a lot of complex code around it, ghidra sometimes introduces a goto in cases like this.","No","Yes","No","Introducing a function to me seems like introducing complexity, which seems bad, but as ghidra does not do that I don't really now how it would work out.
It might be worth a test.
In this case (the same reason as above) I would vote to not copy the block.","","","","","This example is a little bit weird. As Block #4 returns snipped 2 could be drastically simplified. Further, I can't really tell what the underlying machine code is.
If there is an actual variable 'entry_1' (either stack or register) then eliminating the code that sets and reads the value, is not acceptable.
But probably the 'if(var_0 > 10){}' just jumps into the while, in which case the c-scoping semantics are not really obeyed and the cleanest solution would to be a goto.

","No","No","No","","Snippet 2","I assume the compiler did not emit a jump-table and in this case, as there are not even any 'else'-statement it is likely that Snippet 2 is more accurate and has less scoping.","Snippet 2","Same reason as above.","Snippet 2","If Snippet 2 accuratly represents the underlying code, meaning there are no else jumps and in the end it tests for all other conditions being wrong, then Snippet 2 is the best. Otherwise, if the code is an if-else-chain or a jump table, I would prefer Snippet 1.","Snippet 2","Same reason as above. ","Snippet 3","Snippet 1","Snippet 2","In general I think reducing the amout of indentation and the amount of parens is always good.
Though the Snippets are small enought that it does not really matter.","Snippet 1","Snippet 2","Snippet 4","Snippet 3","It somewhat depends on what the actual code is. If there is a variable in the code that caculates x and y I might be persuaded to favor Snippet 3.
","","6733.51","45.81","","","","1801.45","","","","","","","","","","","20.72","","1789.26","","","","","","487.49","","","","","","864.23","","","","","","651.85","","","","","","","","","460.35","","","364.67","","","247.68",""
"4","No","Yes","More than a year","More than a year","","","Cumin","Chilli","Clove","","","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","","No","Yes","Yes","","","","","","","No","Yes","Yes","","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","","No","Yes","Yes","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 1","Snippet 2","Snippet 3","","Snippet 4","Snippet 3","Snippet 2","Snippet 1","","","665.25","26.18","","","","73.27","","","","","","","","","","","2.25","","226.4","","","","","","52.86","","","","","","110.95","","","","","","55.29","","","","","","","","","47.43","","","63.86","","","6.76",""
"6","No","Yes","More than a year","More than a year","","","Chilli","Clove","Cumin","Assuming they are logically equivalent (not heavily scrutinized), 
elimination of deep nesting of if/else is most favorable.
Use of X[i] notation as opposed to *(X + i) might be preferable too.
Identification of a for loop to replace a while loop is useful too.","THe use of undefined8 is not as helpful.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Am assuming code duplication helps in writing a ""cleaner-looking"" while loop. The overall guiding principle is to prevent analysis of additional code that appears elsewhere too. ","No","Yes","Yes","Minimal duplication of instructions would be great. Abstracting logic to a seaprate function to improve the readability for while loops is welcome too.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Reducing duplication is still preferred, as per the previous question.","No","Yes","Yes","Reducing duplication is still preferred, as per the previous question.","No preference","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","While it might be personally more cumbersome to read, the use of entry flags can help to signpost possible code flows.","No","Yes","Yes","Minimal analysis of potentially long code still takes priority.","Snippet 2","Personal preference (even from a software engineering perspective). Less Indentation too.","Snippet 2","Personal preference (even from a software engineering perspective). Less Indentation too.","Both if-Snippets","Personal preference (even from a software engineering perspective). Less Indentation too.","Snippet 1","Both snippet 1 and 2 are fine since the indentation level is relatively significant for snippet 3 here.","Snippet 3","Snippet 2","Snippet 1","Snippet 3 highlights the requirement for conjunction well, with each condition displayed clearly.
Snippet 2 implicitly indicate conjunction well due to nested ifs, which comes at the cost of additional indentation.
Snippet 1 personally is the messiest at first glance.","Snippet 1","Snippet 2","Snippet 3","Snippet 4","Assuming the incrementation amount is not affected by Block #1, it would be best preferred for the amount to be in the for loop.","","1702.95","54.8","","","","410.41","","","","","","","","","","","5.6","","323.74","","","","","","147.73","","","","","","253.06","","","","","","171.1","","","","","","","","","140.71","","","171.73","","","24.07",""
"7","No","No","On a regular basis","A few hours","","","Chilli","Clove","Cumin","1. Chilli: I prefer the constructed switch-case, as it reduces code complexity and improves readability
2. Clove: The RSP/RBP annotations for variable declarations are useful","1. /* format */ annotations
2. Cumin did not resolve the constant format string used in the  __isoc99_scanf call
3. Cumin introduces WAY too much cyclomatic complexity. I think it's hard to follow the control flow there","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","I'd prefer snippet 1 for relatively small code blocks. . However, the larger the block, the harder it would be to visually distinguish between identical code and code with slight differences.","No","Yes","Yes","Snippet 1 creates visuals that cause the code to appear more complex than it must be. My favorite would be Snippet 2, because it provides more ""sequential readability"". Snippet 3 is fine, too, but would require me to read the code less sequentially. This MAY be more beneficial depending on the actual code block and actual function length, because I can analyze the ""outsourced"" code more isolated. Afterward, I know what comes out of this function and know directly what's going on when I see the function call.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","The code's expressiveness, cumulative length, and block size.

The longer the block, the more dangerous it is to overview slight differences when it would be ""copied"".","No","Yes","Yes","Again: It would be too convenient for my brain to see the redundancies of a complex copied block. I'd scan the code real quick and then just skip it.
However, what if there are slight nuances in code that differ? That would be too dangerous for me. ","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","","No","Yes","Yes","","Snippet 2","snippet 2 reduces one depth of indentation. Feels more natural for me to read.","Snippet 1","the more constant cases for a single var, the more natural it feels to me to use and, thus, read, a switch case","Snippet 1","I think a ""default"" case is the more expressive choice here (snippet 1). The two-part condition of snippet 2 takes more ""horizontal-visual-eye-parsing"" and active reading to come to the conclusion that it is basically the default case. Snippet 3 has too much nesting.","Snippet 1","Snippet 3 is bad because of the high nesting
Snippet 2 is bad because the multi-part conditional is way too canonical and complicated.","Snippet 3","Snippet 1","Snippet 2","Snippet 3 works towards me: The relationship between the conditions is clear. I'd then continue, try to understand and then rename them for more expressiveness.
For me, snippet 1 would be one manual step away from snippet 3 -> I'd associate vars and then continue with the same approach used with snippet 3.
Snippet 2 simply sucks: it adds unnecessary nesting and makes reading it so hard, as the conditions are non-trivial an confusing by theirselves","Snippet 2","Snippet 3","Snippet 1","Snippet 4","Snippet 2 feels most natural for me. Snippet 3 is a nice and short for-loop, though I don't like updating x and y in the inner loop scope.
Snippet 1 is LESS expressive than 3, but replaces the x-y update of snippet 3. Yet snippet 3 wins over 2 because of overall clarity. Snippet 4 mixes 1 and 3 and is ""all over the place"".  I have to watch out for non-trivial variable updates in both the inner loop and the official iteration update. No bueno.","","6211.55","14.87","","","","607.87","","","","","","","","","","","21.07","","724.28","","","","","","469.91","","","","","","3237.84","","","","","","541.64","","","","","","","","","286.31","","","303.59","","","4.17",""
"8","No","No","On a regular basis","On a regular basis","","","Chilli","Clove","Cumin","overview: the less indentation the clearer it gets + cleverly reconstructing common code","n/a","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","overview: the less code one sees, the easier it gets to reason about the code","No","No","Yes","I do like this approach since it simplifies and shortens the information on the first look. I'd also suggest to have distinct function names specifically for the decompiler-generated functions.","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","in this case, it's smarter to just break the while loop.","No","No","Yes","When encountering somewhat big repeated code-block, I'd prefer extracting the block as a function.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","","in this case, I'm hesitant to choose the copy feature because sometimes the logic is repeated for a reason, but here you would make it less obvious. ","No","No","Yes","the same explanation as before","Snippet 2","simple condition blocks are rather lengthy when implemented as switch-case block","Snippet 2","same as above","Snippet 1","here it's a special case, it leads to less indentation","Snippet 1","same as above + less logic inside the last if statement","Snippet 3","Snippet 2","Snippet 1","clarity","Snippet 2","Snippet 3","Snippet 4","Snippet 1","clarity","","2408.75","47.02","","","","319.7","","","","","","","","","","","10","","479.32","","","","","","223.5","","","","","","451.88","","","","","","231.19","","","","","","","","","157.75","","","477.42","","","10.97",""
"10","Yes","Yes","More than a year","Several days","","","Chilli","Clove","Cumin","Switch statements in chilli. ","insanely deep nesting. weird for loop (cumin)","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","for short snippets context is clear even if they are copied, leading to cleaner code. copying longer sequences might lead to confusion","No","No","Yes","the reduced complexity in the remaining code due to copying, seems to be balanced with the added complexity of the duplicated block. hiding complexity behind function calls seems much cleaner","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","longer sequences that are duplicated add to complexity","No","No","Yes","complexity between 1 and 2 seems to be balanced. snippet 3 looks clean","No preference","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","breaking condition in snippet 2 is less complex than sequences in option 2 and 3 that would be duplicated","No","No","Yes","again: easy breaking condition with complex duplicated code. having code duplication inside function looks nice","Snippet 2","snippet 2 is shorter and clear to read","No preference","snippet 2 does not look bad, since conditions are easy and  we have no nesting. snipped 1 makes it clear that we are checking for var. no preference","Snippet 1","snippet 1 beats both ""complex"" condition and nesting","Snippet 1","eating complex conditions and nesting up in a default case looks clean","Snippet 3","Snippet 2","Snippet 1","in snippet 1 I get lost in long condition. snippet 2 and 3 tie in ease of following logic","Snippet 3","Snippet 2","Snippet 4","Snippet 1","I prefer easy loop headers (with complexity in body)","","2273.14","65.08","","","","353.06","","","","","","","","","","","19.6","","618.49","","","","","","320.29","","","","","","280.54","","","","","","265.42","","","","","","","","","170.82","","","167.01","","","12.83",""
"12","No","Yes","On a regular basis","On a regular basis","","","Clove","Chilli","Cumin","Note: Chilli/Clove are pretty close.

Clove - It's quite immediately obvious what each branch is doing, because of a) identifying s as being accessed as an array and b) directly indexing with strlen(s) makes it clear what is going on. That made it quite easy to make a good guess at what the function is doing quickly.
Chilli - The switch statement makes the control flow much more obvious. Also, the lifting of the loop conditions into the head of the for loop also helps make the purpose of the loop more immediately apparent.
Cumin - The lift of the loop condition into the loop head is useful.","Clove - if/else branching is messy to read, it is not immediately obvious how or when the loop terminates until reading the end of the loop
Chilli - The branch of each switch statement is a bit harder to understand, and might be considered somewhat misleading - consider the following:
            var_3 = &var_2;
            var_5 = strlen(var_3);
            *(&var_2 + var_5) = 0x30;
            break;
The var_2 is typed as long, so it looks like &var_2 + var_5 is indexing &var_2 as a long * using the strlen character count, and then dereferencing it as a long, which doesn't seem to make sense in this context.
Cumin: I am not sure what 'undefinedn' types are supposed to be (I assume it is a n-byte type), not printing in the short constant string in scanf is a little annoying, the modulus operation on local_18 was not simplified, the control flow within the loop is harder to understand without the switch statement, branches of the switch statement are slightly less concise.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Primary factor is how close it it to code that I think a human might write. I think except for very short blocks like Option 1 it feels more natural to not duplicate the code, even if it makes the control flow a little bit more complex.
Having less code to read is generally good as well, as now I do not have to figure out whether two blocks of code separated by large amounts of other code actually do the same thing or not. At the cost of slightly more complex flow I think this makes reversing easier.","No","Yes","Yes","Not #1, for the reasons I've explained before.
#2 and #3 are acceptable, especially if I can label code lines to quickly know where the break ends up. #3 would be preferred if there is some way to indicate that the call is inlined (just to indicate that there is no actual call happening), and if the extracted routine is complex enough and used often enough to warrant extraction. Extracting out too many of these into functions that don't get reused often enough might hinder understanding.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Similar reasoning as previous question, but now because of additional changes of introducing the temp variable and increased control flow complexity, I feel that I would be more willing to tolerate a few extra lines.","No","Yes","Yes","Same reasoning as before, but here I am leaning more towards call_sub because of the increased control flow complexity in #2.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Similar to previous question, here I think I would lean more towards copying for similar reasons as before.","Yes","Yes","Yes","Similar reasoning as before, but it is a closer choice that I might pick 1.","No preference","There are not enough cases for me to consider a switch an upgrade yet.","Snippet 1","Here there are enough cases that a switch is more readable.","Snippet 1","I think the switch is easier to understand as there is less nesting and clearer conditions, but it is close due to small number of cases.","Snippet 1","Much easier to read the switch statement, handles the larger number of cases easily.","Snippet 1","Snippet 3","Snippet 2","2 is a bit too much nesting for just a single condition, 1 and 3 are reasonably readable (comparable).","Snippet 1","Snippet 2","Snippet 3","Snippet 4","I think the update is not complicated enough to warrant splitting out of the loop head. But if it is split out, i prefer 2 the most as everything is in one place. 3 and 4 are close, maybe tied. ","","10230.6","15.82","","","","3352.7","","","","","","","","","","","8.61","","2414.35","","","","","","2018.92","","","","","","1184.25","","","","","","383.76","","","","","","","","","240.19","","","595.59","","","16.42",""
"13","No","No","More than a year","Several days","","","Chilli","Clove","Cumin","The close relation to the (probably) original C Code, with a switch statement instead of nested if-else blocks in ""Chilli"".","Many variables and nested if-else blocks.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","To copy one return statement is just fine, but if it's more than one or two lines, I think it is confusing, and it bloats the decompiled code.","No","No","Yes","Snippet 3 make sit very clear in which case we run that code.
Snippet 1 does this also, but bloats the logic in the while loop, causing it to be harder to read.
Snippet 2 is still favorable over Snippet 2, but the cases in which the block runs is more implicit and hence also harder to read as Snippet 3.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","To copy one or two lines is preferable for clarity, but more than that can bloat the code and makes it harder to read.","No","No","Yes","The function call in Snippet 3 makes it very clear when the block is executed.
In Snippet 2, this is more implicit and hence harder to read.
Snippet 1 makes this very clear, but bloats the code logic, causing it also to be harder to read as Snippet 3.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Because the nesting is so shallow, copying short blocks is preferable for clarity in this case.","Yes","No","Yes","The function call makes it very clear when the block is executed and don't obstruct the logic.
Snippet 1 also achieve this, but is more bloated than Snippet 3.
Snippet 2 does this more implicit, but is still harder to read.","Snippet 1","I think the logic in a switch statement is more obvious and nicer to read than if-else blocks.","Snippet 1","I think the logic in a switch statement is more obvious and nicer to read than if-else blocks.","Snippet 1","The switch statement is nicer to read.","Snippet 1","I still prefer the switch statement.
It contains fewer brackets, and it is very clear in which case what happens.
Snippet 3 is very complex due to the nesting, and Snippet 2 is better suited for a switch statement.","Snippet 3","Snippet 1","Snippet 2","The extraction of the conditional components in Snippet 3 makes it easier  than Snippet 1 to understand the result of the condition.
Snippet 2 also does this, but introduces mare nesting, which can be harder to read if the code inside is also complex and adds additional nesting.","Snippet 4","Snippet 3","Snippet 1","Snippet 2","I think a for-loop is easier to read in this case as a while-loop.
And to extract a complex operation from the head of the loop increases the readability of the loop.","","3124.91","192.06","","","","428.71","","","","","","","","","","","18.74","","708.94","","","","","","410.3","","","","","","374.6","","","","","","462.59","","","","","","","","","211.97","","","303.5","","","13.5",""
"14","No","Yes","More than a year","More than a year","","","Chilli","Clove","Cumin","Switch cases in Chilli makes code much more readable.","Nested if-else conditions
Some parts of the code would be easier to understand when the integers were in decimal instead of being converting to hex","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","With only 1 return instruction, it's more readable to understand that the function terminates given certain conditions. However, when there's additional logic, probably a shorter code (with no copying) is more readable.","No","Yes","Yes","Snippet 2 will probably be more accurate as it doesn't add additional function calls, but snippet 3 will probably be more readable","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","I find the additional logic of the exit variable more confusing to follow.","Yes","No","Yes","Same as above, I find the additional logic of the exit variable more confusing to follow. And same as previous question, extracting as a function can potentially make it more human-readable but may not be the truest representation of the program.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Same as previously, I find the additional logic of the entry variable more confusing to follow.","Yes","No","Yes","Same as previously, I find the additional logic of the entry variable more confusing to follow. And same as previous questions, extracting as a function can potentially make it more human-readable but may not be the truest representation of the program.","No preference","Both are still quite readable.","No preference","Both are still quite readable.","Snippet 1","Snippet 1 is the easiest to follow, snippet 2 has additional logic to process, snippet 3 has too much nesting.","Snippet 1","Snippet 1 is the easiest to follow, snippet 2 has additional logic to process, snippet 3 has too much nesting.","Snippet 1","Snippet 3","Snippet 2","I think my preferences of the 3 snippets are not really very far apart, but I least like snippet 2 due to the nesting, and probably prefer snippet 1 as that would be closest to how I would write the code.","Snippet 1","Snippet 2","Snippet 4","Snippet 3","1 and 2 are quite clear, and I personally feel for-loops are easier to read. 4 and 3 tends to be a bit confusing as the for-loop operation occurs within the for-loop itself.","","3516.94","173.6","","","","1558.09","","","","","","","","","","","275.14","","607.68","","","","","","313.1","","","","","","74.55","","","","","","145.55","","","","","","","","","194.74","","","165.45","","","9.04",""
"16","No","Yes","On a regular basis","A few hours","","","Clove","Chilli","Cumin","readability: resolved types, shortness, levels of nesting","levels of nesting, unresolved types, pointer arithmetic","","","","","","","","","No preference","No preference","No preference","Snippet 2 (Not copying /* Block #10 */)","If the code gets too long, it's more difficult to see, that it's the same block of code, if it is copied. It's shorter and better to overview, if it's not copied as well. But it depends on the code itself. If the code itself gets more complicated and nested, if the block is not copied, the copied option may be better.","No","No","Yes","Functions are ""clean code"" and it's easy to see, that this is a ""functional"" block, which does exactly one thing and which variables are neccessary for that thing. On the other hand, too much function jumping may hinder the analysis as well, if you get lost and don't know, where you came from.","No preference","No preference","No preference","Snippet 2 (Not copying /* Block #10 */)","If the block gets longer, it is more difficult to see, if it's the same or not. Therefore not copying the block seems more convenient. If depends on the complexity of the overall code though. If the code becomes more difficult to read and more nested, if the block is not copied, the other option may be better.","No","No","Yes","It seems more clean, like ""clean code"" and it is easy to see, that the function is a block on its own, which does one thing and to see, which variables are neccessary for it.
To much function jumping on the other hand may not be beneficial too, because it's easy to loose track, where you came from.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Since the code gets more complicated, if not copyied, but is very easy, if copied, option 1 and 2 are more convenient for snippet 1. But in option 3 the block is very large and snippet 2 becomes more convenient.
","Yes","Yes","Yes","Since the examples are not that complex and long, all 3 options seem to be fine.","Snippet 2","Just don't like switch statements.","Snippet 2","Just don't like long switch statements with blocks in it.","Snippet 2","Same. 
Snippet 3 contains unnecessary nesting which complicates reading it.","Snippet 2","Same.
The default state is nice though, but could be achieved with if/else if/else which would be more logical.","Snippet 3","Snippet 2","Snippet 1","3: wordy but easy to read
2: easy to read but very nested
1: not nested but difficult to read","Snippet 1","Snippet 2","Snippet 4","Snippet 3","1: it's a bit difficult to read, but easy to see, that i is calculated without other dependencies
2,3,4: more easy to read but the additional variable(s) in the loop and different places of calculation complicates up reading it.","","2645.26","26.3","","","","498.17","","","","","","","","","","","7.43","","616.03","","","","","","326.47","","","","","","289.26","","","","","","484.75","","","","","","","","","128.32","","","260.23","","","8.3",""
"17","No","No","On a regular basis","A few hours","","","Chilli","Clove","Cumin","* Low if-nesting
* Proper datatypes","* Chilli: Pointer arithmetic and dereference instead of indexing operator
* Cumin: Deep nesting and unhelpful datatypes
* Clove: Nesting","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Preventing duplicated code, but a single return statement is not worth the more complex control flow.","No","Yes","Yes","Same as before; code duplication is avoided in snippet 2 and 3. 
I prefer 3 over 2.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","The control flow in snippet 2 is too complex to easily understand.","No","No","Yes","Snippet 3 is easy to understand with a simple control flow.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Only entering a loop to break it in the first iteration can be hard to follow, so I would prefer to avoid snippet 2.","No","No","Yes","Snippet 3 is the best solution due to the simple control flow.","Snippet 1","Snippet 1 highlights the exclusiveness of the two arms which is not immediately visible in snippet 2 due to the missing ""else if"".
Also, it's easier to spot that we are comparing the same variable against multiple constants in snippet 1.","Snippet 1","Snippet 1 highlights the exclusiveness of the two arms which is not immediately visible in snippet 2 due to the missing ""else if"".
Also, it's easier to spot that we are comparing the same variable against multiple constants in snippet 1.","Snippet 1","Snippet 1 highlights the exclusiveness of the two arms which is not immediately visible in snippet 2 due to the missing ""else if"".
Also, it's easier to spot that we are comparing the same variable against multiple constants in snippet 1.

In this case, the switch also has the simplest control flow.","Snippet 1","Snippet 1 highlights the exclusiveness of the two arms which is not immediately visible in snippet 2 due to the missing ""else if"".
Also, it's easier to spot that we are comparing the same variable against multiple constants in snippet 1.

In this case, the switch also has the simplest control flow.","Snippet 1","Snippet 2","Snippet 3","If the third condition was more complex, I'd prefer snippet 2 over 1, but in this case it's simple enough to be easily readable in snippet 1.
Snippet 3 is very unnatural, snippet 2 is fine but the nesting is unnecessary.","Snippet 1","Snippet 2","Snippet 4","Snippet 3","Having the loop increment statement reference variables that are set in the loop is hard to follow (snippet 4 and 3), having a while loop instead of a for loop can also be harder to read (You have to watch out for continues to make sure the loop counter changes in each iteration).","","1726.75","29.52","","","","297.05","","","","","","","","","","","17.51","","339.31","","","","","","183.46","","","","","","211.68","","","","","","218.02","","","","","","","","","145.88","","","269.17","","","15.15",""
"18","No","Yes","More than a year","Several days","","","Clove","Chilli","Cumin","variable name numbering","nil","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Even if Snippet 1 has a simplified structure, a lengthy and repeated ""Block #10"" would not make it easier to read as compared to Snippet 2.","No","No","Yes","It reduces the number of code lines and is very readable with an appropriate function name.","","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","it feels less complicated to read when the code is more segregated.","No","No","Yes","substituting function calls with makes it easier to read.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 has a significantly more simplified structure to tolerate the copying.","No","No","Yes","substitute with functions calls makes it easier to read","Snippet 1","nil","Snippet 1","nil","Snippet 1","switch-case is most readable out of the 3 choices","Snippet 1","switch-case is most readable out of the 3 choices","Snippet 3","Snippet 2","Snippet 1","Tidy","Snippet 3","Snippet 4","Snippet 2","Snippet 1","Neat","","3281.72","85.32","","","","814.52","","","","","","","","","","","14.72","","999.83","","","","","","743.07","","","","","","192.84","","","","","","286.51","","","","","","","","","64.11","","","70.6","","","10.2",""
"19","No","Yes","Several days","Several days","","","Chilli","Cumin","Clove","Chilli had cleaner and more human readable codes. This makes analysis much easier as compared the one seen in Cumin.","While loops as seen in Clove were unhelpful and impedes analysis when determining the flow of the program.","","","","","","","","","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Single line codes will take less effort in terms of analysis, in terms of the example, a return shows the end of a pathway quickly, allowing for (targeted) quick dives of code snippets as compared to full code analysis.

Longer codes (Option 2 and 15) will require more tactful approach as this functions occurring twice in a single function may throw off the analysis and waste valuable time re-analyzing a function that has already been dived through.","No","No","Yes","Snippet 3 is cleaner and prevent un-necessary re-analysis of code snippets (as seen in snippet 1).","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","As Previously stated, shorter codes that needs not be re-analyzed can be repeated, and repeats of longer code snippets should not.","No","Yes","Yes","Less analysis required and no repeated functions. Functions are read 1-pass and in the case of snippet 3, code is separated in different function and can be analyzed seperately","No preference","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","single line and small (simple) code snippets can be repeated, but long snippets should not be to prevent unnecessary re-analysis of code.","No","Yes","Yes","single line and small (simple) code snippets can be repeated, but long snippets should not be to prevent unnecessary re-analysis of code.

Having the code separated out as a function also allowed for cleaner analysis as the function can be analysed as a separate unit","No preference","The readability of Switch Cases and Ifs are dependent on the code snippet prior, and which determines the flow of the code.

The readability of switch cases/if statements can drastically change based on the value that undergoing the logic statements. ","No preference","The readability of Switch Cases and Ifs are dependent on the code snippet prior, and which determines the flow of the code.

The readability of switch cases/if statements can drastically change based on the value that undergoing the logic statements. ","Snippet 1","Switch case looks the cleanest and directly readable in this snippet","Snippet 1","Switch case provides the most readable output for this snippet.","Snippet 3","Snippet 2","Snippet 1","Code is most verbose and has semantics","Snippet 3","Snippet 4","Snippet 2","Snippet 1","Snippet 3 was easily understood, while snippet 4 required determining the logic within the for loop. Snippet one was essentially code-golfing (not essential), and while loop is harder to understand without extra effort into anlysing it.","-","5037.59","46.96","","","","2060.87","","","","","","","","","","","7.38","","1300.2","","","","","","543.4","","","","","","442.66","","","","","","286.08","","","","","","","","","132.43","","","211.71","","","5.9",""
"20","Yes","Yes","More than a year","A few hours","","","Chilli","Clove","Cumin","Propper switch-case extraction","to many local variables, deeply nested control structures","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","single statements are tolerable","No","Yes","Yes","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","","No","Yes","Yes","","No preference","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","","No","No","Yes","","No preference","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 3","Snippet 1","Snippet 2","","Snippet 4","Snippet 3","Snippet 1","Snippet 2","","","720.31","33.16","","","","105.23","","","","","","","","","","","3.9","","164.7","","","","","","120.88","","","","","","121.43","","","","","","52.3","","","","","","","","","30.95","","","82.41","","","5.35",""
"22","Yes","No","More than a year","Several days","","","Chilli","Clove","Cumin","The use of switch case to simplify the code.","The use of &local_68 + sVar1 in Cumin seems largely unhelpful.","","","","","","","","","No preference","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Is there is too many instructions then it will over complicate things if we repeat it.","No","No","Yes","Makes things look simpler as long as it is clearly mentioned that it is a decompiler only function","No preference","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","If its too long then copying will overcomplicate things","No","No","Yes","Looks similar to how you would do in C code","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","Length of copied code","No","No","Yes","easiest to understand","Snippet 2","switch statement seems unnecessary. Also not sure if they have the same meaning as snippet 2 can possibly execute both blocks 1 and 2 but snipper 1 cannot.","Snippet 1","Looks cleaner","Snippet 1","Looks cleaner","Snippet 1","Looks cleaner","Snippet 3","Snippet 2","Snippet 1","Easiest to understand","Snippet 1","Snippet 2","Snippet 3","Snippet 4","Closest to how I would implement in C","","2279.36","60.03","","","","624.13","","","","","","","","","","","7.24","","420.3","","","","","","484.1","","","","","","377.64","","","","","","144.53","","","","","","","","","34.05","","","120.26","","","7.08",""
"23","Yes","Yes","On a regular basis","On a regular basis","","","Chilli","Clove","Cumin","Easier control-flow analysis (e.g. prefer switch statements rather than convoluted if-else statements)","Referencing static data through global variable (Cumin: __isoc99_scanf(&DAT_00403259,&local_18);).
Would rather not click on the variable to find out what it actually is.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","A simple return statement will be good in guiding control-flow analysis. 

However when there are additional n operations performed before the return, it may complicate/make analysis less intuitive. For example if there are huge chunks of operations done before the program return, I may forget what happens during a return and analyse the n operations again. In this case, having the /* Block #10 */ in a single place helps simplify my thought process.","No","Yes","No","Would rather have the block in a single location as explained previously. Also would rather the block not be extracted out as a function as I would prefer seeing everything in one place (rather than clicking on the call_sub function and to see what's going on).","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Easier to analyze control-flow if there is just a simple return statement.

However when there are operations done before the return, I would rather have them all in one place (not copying) since it would simplify my analysis. For example, if there are a huge chunk of operations done before the return block, I may have forgotten what was being performed in the return and attempt to analyze the return block again. I rather have them in one place so I can add comments on their meaning in a single location where I can refer to.","No","Yes","No","Would prefer the return block in one place as explained previously.

Also would prefer the block not be extracted out as a function as I would rather have everything in one place for easier analysis (I don't have to click the call_sub function to analyze it).","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","In snippet 2, I would only have to analyze the if statement in line 10 to determine if the block will be executed at least once. However for snippet 1, I have to analyse the if statement in line 4 and the while statement in line 9 to determine if the block will be executed.","No","Yes","No","Same reasoning as the previous part (would prefer not extracting the block as a function)","Snippet 2","If statements are more intuitive to me if there are only a few cases.","Snippet 1","If there are many cases, switch is easier to understand. I would know that a block of operations will be performed based on the value of var in one glance.","Snippet 2","In snippet 1, have to perform the additional step of analyzing what the default case mean (var != 1 && var !=2). This means I will comment it at line 9 anyway. Thus I would prefer having the condition explicitly written out in snippet 2 like in line 8.

Snippet 3 seems unnecessarily convoluted.","Snippet 1","Would prefer snippet 1 over snippet 2 as the last condition (line 17) seems too long for it to be intuitive.","Snippet 1","Snippet 3","Snippet 2","Most prefer snippet 1 as I like to have the conditions in one view.

Snippet 3 helps break down the analysis, but I would prefer everything in one place.

Least prefer snippet 2 as I don't like nested if statements.","Snippet 1","Snippet 4","Snippet 3","Snippet 2","Prefer for loops the most as I could explicitly see when the loop terminates.
Prefer the for loop in snippet 1 the most as I could easily see how the loop variable i updates in one statement.","","2154.96","21.4","","","","295.15","","","","","","","","","","","9.36","","439.21","","","","","","322.11","","","","","","347.2","","","","","","335.68","","","","","","","","","116.03","","","264.42","","","4.4",""
"25","","","Several days","Several days","","","Chilli","Cumin","Clove","","","","","","","","","","","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","","No","Yes","Yes","","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","","No","Yes","Yes","","No preference","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","","Yes","Yes","Yes","","Snippet 2","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 3","Snippet 2","Snippet 1","","Snippet 2","Snippet 3","Snippet 4","Snippet 1","","","756.94","25.03","","","","52.04","","","","","","","","","","","1.96","","193.42","","","","","","195.5","","","","","","49.28","","","","","","146.23","","","","","","","","","37.82","","","52.33","","","3.33",""
"26","Yes","Yes","On a regular basis","On a regular basis","","","Chilli","Clove","Cumin","Chilli: Use of switch statement. Use of for loop instead of while loop makes the condition more clear as well. The lack of type casting also makes it looks cleaner (although it would be useful for user to enable typecasting to be shown).

Clove: Deduction of the ""s"" as char array and then indexing it automatically is helpful.","Cumin: Heavily nested if statement makes it hard to read. Showing DAT_00403259 instead of the string literal ""%lld"" means user have to waste time and check the variable and fix it (presumably to make it read-only).","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Copying is fine as long as it is not too long. Forcing it to be a single block can make other code structure become harder to read. E.g. snippet 2's while loop contains several break statement which makes it harder to follow.","No","No","Yes","Snippet 3 retains the clarity of the while loop without introducing break statements. The copying of the ""call_sub"" is fine as it is only a single line. Furthermore, user can rename the ""call_sub"" function to make it descriptive.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Copying is fine for short instruction sequences. Not copying makes sense for long instruction sequence. But the multiple exits in the while loop makes it harder to read.","No","No","Yes","While loop is more readable without multiple exits. User can also rename the ""call_sub"" to make it more descriptive.","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Length of the copy affects readability.","No","Yes","No","It's more concise to have everything viewable from a single function. Furthermore, it doesn't create any artificial function calls. Perhaps it would be useful to allow user to collapse the while statement.","Snippet 2","If statement is more concise when it's just 2 cases.","Snippet 1","Switch is easier to read when there are many cases.","Snippet 1","Switch is easier to read.","Snippet 1","Switch is more concise. Nested if statements makes it hard to read.","Snippet 1","Snippet 2","Snippet 3","Snippet 3 allows user to rename the conditions to make it clearer. Snippet 2 is clearer than 1 since it breaks up the conditions.","Snippet 3","Snippet 4","Snippet 1","Snippet 2","For statement is more concise that while statement. Separating the conditions into x and y variable allows user to rename them.","","2436.01","22.58","","","","751.31","","","","","","","","","","","7.18","","474.4","","","","","","289.81","","","","","","452.74","","","","","","123.21","","","","","","","","","103.22","","","199.05","","","12.51",""
"29","No","No","Several days","A few hours","","","Cumin","Clove","Chilli","Chilli is able to identify and decompile as a case-switch. Clove however provides good detail on declaration of variables which may be useful
It would be good to have the option to display constants either as hex or decimal depending on preference.","Large nested if-else","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Once we've identified a unique block of code, repetition is fine since we can easily mark and understand the function. 
It's more important to have a simplified structure to better understand the overall flow. ","No","No","Yes","Extracting it out as a function further helps us in identifying a unique block of code across different sections, and is naturally more helpful for interpretation","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Same as earlier","No","No","Yes","Same as earlier","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Same as earlier","No","No","Yes","Same as earlier","Snippet 1","Case switch presents a more intuitive understanding of the flow of the code.","Snippet 1","Case switch presents a more intuitive understanding of the flow of the code. ","Snippet 1","Case switch presents a more intuitive understanding of the flow of the code. ","Snippet 1","Same as earlier, even more so for this case. It simplifies the structure massively","Snippet 3","Snippet 2","Snippet 1","Snippet 3 most succinctly describes the conditional arguments in an intuitive manner, stating each condition before chaining them together. For similar reasons, Snippet 2 is preferred over snippet 1 despite containing nested if-else statements","Snippet 1","Snippet 3","Snippet 4","Snippet 2","Snippet 1 most clearly states the conditions of the for loop in a single sentence without additional confusing variables. Snippet 2 is deemed the worst since the changes in c can easily be lost in the block of code in between","","1210.26","33.27","","","","296.98","","","","","","","","","","","4.53","","306.68","","","","","","72.57","","","","","","40.4","","","","","","120.29","","","","","","","","","118.1","","","214.3","","","3.14",""
"30","No","No","Several days","Several days","","","Chilli","Clove","Cumin","Switch makes things easier to read for me, compared to repeatedly nested if-else.","","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","For shorter snippets I prefer it to be copied since it helps me parse the flow better; forcing a break out of a while(true) just to handle it without copying seems a bit strange to me.

I put no preference for longer snippet because it really depends on how long the other code blocks are as well; i think there's merit to keeping code short of the rest of the code is already super long.","No","No","Yes","Helps to meet the criteria I stated for my choices in the previous question; flows better, and helps to shorten the code.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Same as previously, I like having the flow in Snippet 1, and the ""exit"" flag and immediate check feels strange to me. But I can see the argument for shortening it if the code blocks are too long.","No","No","Yes","Like the previous question, I like to extract as function to allow me to maintain the flow while reducing code length.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","No preference","Same as previous.","No","No","Yes","Same as previous","Snippet 2","Two choices I don't think calls for a switch, just a personal preference. I prefer when switch is used for numerous options, but for two I prefer simple ifs.","No preference","I prefer when switch is used for numerous options: for 5 i am okay with both versions, personal preference.","Snippet 1","The default case for switch looks cleanest and most straight forward to me, the ifs just complicate things.","Snippet 1","Again, with default cases, switch should probably be used","Snippet 3","Snippet 2","Snippet 1","I dislike having too many conditions in one line, so Snippet 1 is my least favourite. Snippet 3 is my favourite as it clearly marks out each of the 3 conditionals, allowing me to consider them more easily.","Snippet 3","Snippet 2","Snippet 4","Snippet 1","Snippet 1 least favourite because it is all in one line, hardest to parse. 
Snippet 2 and 4 is next because I prefer to see more than 1 variable to manage the loop counter, but 4 is a bit confusing still.
Snippet 3 is the cleanest to me.","","3144.51","19.16","","","","222.44","","","","","","","","","","","12.38","","381.38","","","","","","1693.41","","","","","","118.72","","","","","","230.51","","","","","","","","","122.52","","","339.27","","","4.72",""
"31","Yes","No","More than a year","More than a year","","","Chilli","Clove","Cumin","- Appropriate use of switch-case
- Omission of redundant checks
- Omission of implied typecasts
- Use of /=, which is quite succinct","- Omission of redundant checks must be done carefully, in case there may be some vulnerabilities in the checks, e.g. overflows","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","- I prefer while-condition loops to while-true loops with many inner checks, as they are easier to interpret.
- It is hard to compare longer snippets and notice that they are identical.

Possible solutions:
- Inline function
- Goto label","No","No","Yes","It avoids both problems of the while true loop and comparing long snippets.
I would prefer the function to be marked ""inline"", and would not mind a goto-label structure if used once per function.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","- A while-true loop with many breaks and continues is confusing, so I prefer the while-condition loop with the copied block.
- It is hard to compare longer snippets and notice that they are identical.","No","No","Yes","It avoids both problems of the while-true loop and comparing long snippets.
I would prefer the function to be marked ""inline"", and would not mind a goto-label structure if used once per function.
","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","- I prefer while-condition loops to while-true loops
- The entry_1 flag is hard to keep track of
- It is hard to compare longer snippets and notice that they are identical, so I prefer not copying them.","No","No","Yes","It avoids all the problems of the while-true loop, flags, and comparing long snippets.
I would prefer the function to be marked ""inline"", and would not mind a goto-label structure if used once per function.
","No preference","Both are fine, as they are short and uniform.
- The switch-case structure has no weird fall-throughs
- The if conditions have no overlaps","No preference","Both are fine, as they are still uniform.
- The switch-case structure has no weird fall-throughs
- The if conditions have no overlaps","Snippet 1","The final none-of-the-above case corresponds well to the ""default"" part in switch-case. 
Other than Snippet 1, I would also be fine with Snippet 3, as the else case rules out overlapping conditions, unlike in Snippet 2 where I need to double-check. ","Snippet 1","The final none-of-the-above case corresponds well to the ""default"" part in switch-case. 
Snippet 2 has a messy final case with too many conditions to eyeball.
Snippet 3 has too much nesting, but it would work fine if the formatting allowed ""else if"" to be on the same line and not indented.","Snippet 3","Snippet 1","Snippet 2","I am used to Snippet 1 where all conditions are crammed into one ""if"", but I like Snippet 3 for extracting booleans that I can label.
For Snippet 2, nesting is unnecessary when there is no else case.","Snippet 4","Snippet 3","Snippet 1","Snippet 2","Snippet 4 seems to have the best balance between simplifying the update statement and introducing new variables. 
I prefer for loops to while loops, as it's easier to find the update statement(s).","It would be nice to have some kind of auto-save to our survey token, as both times I accidentally exited before finishing or saving and had to redo it. 

Thanks for the effort and good ideas!","1827.67","17.56","","","","124.63","","","","","","","","","","","3.82","","318.98","","","","","","233.32","","","","","","280.51","","","","","","511.61","","","","","","","","","122.51","","","125.67","","","89.06",""
"32","Yes","Yes","More than a year","More than a year","","","Chilli","Clove","Cumin","readability of chilli, using switch case instead of if else resulting in less indentations and also easy to read which conditions will trigger which code path.","if else instead of switch case","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","If the same block of code can be presented without copying (so there is only one block to process) it is much simpler to understand the code flow and logic. Having two (or more) exact copies of a block of code in a function makes the logic generally harder to understand, takes up more screen real-estate and is just generally annoying because it needs to be abstracted out by your mind when processing the logic of the decompiled code.","No","No","Yes","Snippet 3 is able to achieve a simplified structure (ie. easier to understand the control flow compared to snippet 2) but still keep the decompiled code neat and not introduce too many lines of repeated code which takes up more screen space.","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","I can see the value of simplifying the structure like in Snippet 1 but in this case, the control flow is easy enough to understand and IMO is not worth the trade-off of having to repeat the same code block.","No","Yes","Yes","Repeated code blocks is quite annoying and requires more focus to abstract out when understanding the decompiled code logic.","No preference","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Copying code here does make the conditions for  block #4 to be executed clearer. However, if block #4 is large, it is going to be annoying to read.","No","Yes","Yes","As mentioned earlier, having to read repeated code blocks in 1 function (Snippet 1) is annoying.","Snippet 1","neater, less braces :) and if it's a long statement, you'll immediately know that the control flow is determined by 1 variable (var).","Snippet 1","neater, less braces :) and if it's a long statement, you'll immediately know that the control flow is determined by 1 variable (var).","Snippet 1","neater, less braces :) and if it's a long statement, you'll immediately know that the control flow is determined by 1 variable (var).","Snippet 1","neater, less braces :) and if it's a long statement, you'll immediately know that the control flow is determined by 1 variable (var).","Snippet 3","Snippet 2","Snippet 1","snippet 3 is way easier to read because the conditions for the if-statement is very clearly defined.","Snippet 2","Snippet 1","Snippet 3","Snippet 4","putting the loop exit condition logic together makes it easier to read the code. It gets harder/more annoying when they are separated like in Snippet 4 (x - (i >> 32)). Then I have to look at what is 'x' at the bottom of Block #1. Then it turns out that x is related to i as well... Might as well put them together.","Thanks for the opportunity.","2799.99","30.04","","","","285.75","","","","","","","","","","","9.01","","719.88","","","","","","350.14","","","","","","479.23","","","","","","606.62","","","","","","","","","71.44","","","234.58","","","13.3",""
"34","No","Yes","More than a year","A few hours","","","Chilli","Clove","Cumin","type information and avoiding deeply nested ifs","deeply nested ifs","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","the sequence of conditions that have to be checked is clearer","No","No","Yes","refactoring is lit","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","isn't this the same thing as the last part","No","No","Yes","refactoring is still lit","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","while(true) is annoying with the exit conditions","No","No","Yes","once again, refactoring is lit","Snippet 1","I immediately see that I only need to think of the value of var for all of this switch statement","Snippet 1","I immediately see that I only need to think of the value of var for all of this switch statement","Snippet 1","I immediately see that I only need to think of the value of var for all of this switch statement (why no if - else if - else?)","Snippet 1","I immediately see that I only need to think of the value of var for all of this switch statement","Snippet 3","Snippet 2","Snippet 1","top choice makes it clear that we have 3 conditions, what they are, and that all have to be true. Bottom choice has too much in one line","Snippet 2","Snippet 4","Snippet 1","Snippet 3","I hate for loops with anything else but i++ or i--","I feel like using the /* BLOCK x */ stuff skews perception of the snippets heavily","1400.59","131.04","","","","173.12","","","","","","","","","","","4.56","","369.19","","","","","","96.2","","","","","","139.34","","","","","","198.63","","","","","","","","","80.76","","","163.38","","","44.37",""
"37","No","No","More than a year","On a regular basis","","","Chilli","Cumin","Clove","Data types, sufficient verbosity e.g. switch case statement not expanded into if-else","Data types as WORD/QWORD, switch case expanded into if-else","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Repetition is fine for short instruction sequences else the readability will be affected","No","Yes","Yes","Length of instruction sequence is too long for snippet 1. It is fine to be inlined in snippet 2 or as a function call","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Option 1 is short enough to be repeated but not option 2 and 3","No","Yes","Yes","Snippet 2 and 3 are cleaner and easier to read","Snippet 2 (Not copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Shorter instruction sequence for readability. The logic flow is not lost in snippet 2.","No","No","Yes","Easier to understand a more complex set of instructions when they are extracted out into a separate function","No preference","Depends on the length of the switch case/if-else. Switch case might be more appropriate for a greater number of conditions while multiple if-else has better readability when representing a small number of conditional statements","Snippet 1","switch case for a bigger number of conditional statements is easier to read and understand","Both if-Snippets","if-else better for 3 conditional blocks","Snippet 1","Easier to understand","Snippet 2","Snippet 3","Snippet 1","Sufficient verbosity and readability tradeoff","Snippet 3","Snippet 4","Snippet 1","Snippet 2","How easy it is to understand the logic","","1832.74","20.47","","","","364.27","","","","","","","","","","","84.02","","569.72","","","","","","116.24","","","","","","205.76","","","","","","263.03","","","","","","","","","76.1","","","125.04","","","8.09",""
"38","","Yes","Several days","A few hours","","","Clove","Chilli","Cumin","- using a switch statement
- using decimal values
- using a while loop
- indexing arrays instead of using offsets
- using less type casts","- using long nested else-if constructs
- using hex values (when not optimal for readability like e.g. for addresses)
- using many type casts
- array offset arithmetics  
- no or undefined variable types","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","The structure of snippet 1 is much better in general, because blocks 6, 7 and 11 don't need to be in the loop. If the code duplication is too much, i would prefer the worse structured code, though.","No","No","Yes","For such a large section, function extraction is a very good choice.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","As in the last step, I would prefer duplication as long as its not too much. I like function function extraction even more, though.

P.S.: What happened to Block #3 in the first example?","No","No","Yes","I think function extraction makes sense here (because of the length of the block)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","The structure in Snippet 2 is really ugly and hard to unwind (when the actual blocks are filled in).","No","No","Yes","Function extraction is the best choice here, IMHO.","Snippet 2","When there are no nested  `else if ()` constructs and only two options  a switch isn't really worth the effort","Snippet 1","because of the sheer number of cases, a switch statement improves readability here IMHO","Snippet 1","Snippet 2 is just ugly and snippet 3 is unnecessarily convoluted with its nested if statements. Furthermore, a default block in a switch statements is very intuitive and therefore easy to comprehend","Snippet 1","Is there even a choice here? Snippets 2 and 3 are gruesome in comparison.","Snippet 2","Snippet 3","Snippet 1","Snippet 1 is harder to read. Snippets 2 and 3 are both OK, I guess. Snipped 2 looks better but #3 uses less nesting. I prefer #2 a bit. because storing the values in variables distracts a bit from program flow.","Snippet 2","Snippet 3","Snippet 4","Snippet 1","Having complex operations inside the for loop definition is a bad idea IMHO. What is more, I think while loops have better readability most of the time. By substituting most of the operations, #3 is ""the best of the rest"".

P.S.: Why the `>> 5 >> 2`? Isn't that just the same as `>> 7`?","The usability was very good IMHO","3573.99","23.28","","","","660.22","","","","","","","","","","","12.81","","413.33","","","","","","427.73","","","","","","612.26","","","","","","510.26","","","","","","","","","323.06","","","537.31","","","53.73",""
"39","No","No","Several days","A few hours","","","Chilli","Clove","Cumin","Use of switch-case instead of endless if/else if","Refer to this: https://i.imgur.com/BtjZedW.jpg","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Just the length of the code","No","No","Yes","Extracting functions is the way to go, at least for anything larger than a few lines in my opinion","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Readability mostly","No","No","Yes","Refactor anything that is longer than a few lines and occurs multiple times","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","","No","No","Yes","","Snippet 2","For just two cases, if-elif is better in my opinion. ","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 3","Snippet 1","Snippet 2","","Snippet 1","Snippet 2","Snippet 3","Snippet 4","","","1154.61","19.31","","","","249.69","","","","","","","","","","","21.98","","217.62","","","","","","149.24","","","","","","122.22","","","","","","143.47","","","","","","","","","58.24","","","165.35","","","7.49",""
"40","No","No","On a regular basis","Several days","","","Chilli","Cumin","Clove","The decompiled switch-case, and i find ""var_2"" easier to read than v2. Also the local vars in chilli help the understanding
I like that clove displays the stack offsets of the variables","in clove the statements in the form of ""*(_WORD *)&s[strlen(s)] = 56;"", so as a one-liner, are very hard to read. The long else-if chain is inferior to the switch case.","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","As soon as multiple lines are duplicate i am caught up checking if they are actually duplicate, or if there are small nuances/differences that i might overlook","No","No","Yes","Now i dont have to worry if the snippets are actually identical, as i described before","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Same reason as in the last question (hard to see if actually identical or different)","No","No","Yes","again same reason as in the last question (easier to see that its identical)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","the ""copying"" version is for more readable for me, but if there are too many instructions it becomes messy again","No","No","Yes","I find the copying version easier to read, and now there is no duplicate code.","Snippet 1","switch cases make it easy to directly see the structure of the code","Snippet 1","switch cases make it easy to directly see the structure of the code","Snippet 1","switch cases make it easy to directly see the structure of the code","Snippet 1","switch cases make it easy to directly see the structure of the code","Snippet 3","Snippet 2","Snippet 1","1 is barely readable, and 3 breaks everything down in seperate parts, making it easier to understand","Snippet 2","Snippet 3","Snippet 4","Snippet 1","i prefer the least amount of logic possible inside the loop definition","","1240.24","60.85","","","","339.19","","","","","","","","","","","6.97","","314.68","","","","","","120.59","","","","","","175.63","","","","","","69.99","","","","","","","","","65.48","","","84.2","","","2.66",""
"41","Yes","No","More than a year","Several days","","","Chilli","Clove","Cumin","the switch statement ist easier to understan","the exessive type casts in Cumin are confusing, especially with casts to ""undefined""","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","to me its about the visual impact of the block more than its true length or complexity, option 3 has a huge visual impact because it is both long (number of lines) as well as wide (lots of long-ish text literals).
option 2 is right at the borderline for me. i'd be okay with either copying or not copying in this case","Yes","No","Yes","the block is again on the borderline of visual impact for me, but I dislike excessive break-ing.
snippet 3 is a really elegant solution, both minimizing excessive breaking as well as having to re-extract the same semantics from a block of code","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","i dislike excessive break-ing and the branch conditions are more complex in snippet 2, but the visual impact of option 3 is too large for copying","Yes","No","Yes","again, excessive breaking in snippet 2 and more complex branch conditions
visual impact of the block is near the borderline for copying","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","while the visual impact of option 3 is significant, in this case the increase in complexity of snippet 2 compared to snippet 1 outweighs the visual impact","Yes","No","Yes","snippet 3 is by far my favourite but I'd be okay with analyzing snippet 1","Snippet 1","the switch statement adds inherent semantics compared to the if conditions, making it easier to glance the purpose of the code","Snippet 1","same as above, the switch statement adds inherent semantics compared to the if conditions, making it easier to glance the purpose of the code","Snippet 1","same as above, plus defaults are easier to understand with the switch statement","Snippet 1","same as above, still in favour of the switch, only even worse if snippets than before","Snippet 3","Snippet 1","Snippet 2","snippet 3 is easiest to glance, while snippet 2 hides the inherent and-ing of the conditions","Snippet 2","Snippet 3","Snippet 4","Snippet 1","snippet 1 is too complex in the for header. I generally prefer for-loops over while, but with a complex update such as this I prefer the while loop. snippet 3 is okay but I feel like the update of a for-loop should be self-contained, i.e. not partially in the for-header and partially in the body. Snippet 4 has the same problem as snippet 3 but is also more complex in the for-header","","1443.12","44.33","","","","194.16","","","","","","","","","","","11.53","","414.52","","","","","","189","","","","","","132.38","","","","","","165.35","","","","","","","","","84.66","","","203.59","","","3.6",""
"42","Yes","No","More than a year","More than a year","","","Chilli","Clove","Cumin","Chilli has the least amount of nesting. For this example less nesting means much better readability.
Clove contains less typecasting than Cumin.","Chilli mixes base-10 and hex-representations of integers for their cases. I prefer a consistent usage of only one of the two.
Chillis representation does not contain information about stack positions of variables, which can be quite useful in cases where the decompiler output is not completely correct.","","","","","","","","","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","For small snippets I only care about how easy it is to follow and understand the control flow.
For larger snippets (5 lines or more?) less repetition means less time spent on trying to understand the same code twice.","No","Yes","No","As above, less repetition means less time spent on trying to understand the same code twice.
Extracting the code snippet into its own function yields a very readable control flow but also implies adherence to calling conventions! Depending on the analysis questions this can actually be counterproductive, especially if the analyst blindly assumes that the original assembly code also adheres to a calling convention here.","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Less repetition means less time spent on trying to understand the same code twice. But if I have to pay for it via more complex control flow conditions (like that exit_1 variable), I lean on preferring easier control flow most of the time.","Yes","Yes","No","As mentioned in a previous question, I do not like the implied adherence to a calling convention in snippet 3 if it may not be true.","No preference","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Side note: All options end in return instruction, which seems somewhat wrong considering the code of the two snippets.

Except for repetition of large snippets I prefer less variables that need to be followed to understand the control flow.","Yes","No","No","Snippet is not long enough for me to mind the repetition. I would actually prefer snippet 3 if it were not for the implied adherence to a calling convention that may not actually be true.","Snippet 1","Snippet 1 makes it clearer that the code cannot execute both block 1 and 2 but only one of them.","Snippet 1","Snippet 1 makes it clearer that only one of the blocks get executed.","Snippet 1","I generally like the readability of switch cases.
Snippet 2 is the worst of the three, since one first has to check that block 1 and 2 do not change the variable before one knows that the code is equivalent to the other two. This means more analysis work compared to snippets 1 and 3.","Snippet 1","I still like the readability of switch-cases.
Here snippet 3 is the worst since it reaches a nesting depth that greatly hurts readability.","Snippet 1","Snippet 2","Snippet 3","I actually would prefer snippet 4 here (inspired by what the standard code formatter for the Rust language does):

if( (a == 5) 
     && (c <= 3d-4) 
     && ( ((x+y) < (z <<2)) 
            || (u > 20) ) )
{
	// do something
}","Snippet 1","Snippet 2","Snippet 4","Snippet 3","Snippets 3 and 4 split the loop variable handling between the top and the bottom of the loop, which is bad.
Snippets 1 and 2 have the same readability to me, here I can only say on a case-by-case base which one I prefer.","I think I already mentioned that looking at what the standard Rust code formatter does for way too complex code constructs could also be useful for decompiler output. Sometimes smart intendation of code helps more in the way of readability than rewriting the code with a different control flow style.","4731.24","72.52","","","","854.19","","","","","","","","","","","12.94","","878.55","","","","","","623.61","","","","","","529.18","","","","","","620.72","","","","","","","","","377.08","","","279.27","","","483.18",""
"43","No","Yes","Several days","None","","","Chilli","Clove","Cumin","switch-case instead of nested if-else
for loop instead of while loop","clove uses instructions like *(_WORD *)&s[strlen(s)] = 70; which are not readable at all
big amount of undefined local variables (in contrast to chilli)","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","1. Keep your code DRY, always!
2. Snippet 2 is easier to read because the code is better structured","No","Yes","Yes","1. Again the DRY argument
2. extracting code to a separate function (separation of concerns) is good for readability","Snippet 1 (Copying /* Block #10 */)","No preference","No preference","No preference","If block 10 would be moved to a separate function, I would always prefer snippet 1","No","No","Yes","Has the advantage of having the simpler/more readable structure with benefit of DRY code","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","","No","Yes","Yes","","No preference","Both snippets are easy to read. Anything more complex than that should be a switch","Snippet 1","Since every condition uses var, it only makes sense to use a switch","Snippet 1","Intuitively understandable code","Snippet 1","Intuitively understandable code","Snippet 3","Snippet 2","Snippet 1","
","Snippet 2","Snippet 3","Snippet 1","Snippet 4","","","2187.74","27.97","","","","347.46","","","","","","","","","","","15.09","","701.73","","","","","","370.17","","","","","","139.86","","","","","","261.46","","","","","","","","","168.09","","","117.29","","","38.62",""
"46","No","No","On a regular basis","A few hours","","","Chilli","Clove","Cumin","switch case instead of nested if else statements","nested if else statements","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","An easy structure makes it much quicker to understand the code. So I always prefer an easiert to read structure ","No","No","Yes","It looks like its the most readable version ","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","I prefer an easy structure instead of less code","No","No","Yes","just the easiest to read and understand","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","","No","No","Yes","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 1","Snippet 3","Snippet 2","","Snippet 1","Snippet 2","Snippet 4","Snippet 3","","","931.33","40.28","","","","173.66","","","","","","","","","","","10.63","","362.24","","","","","","113.9","","","","","","105.13","","","","","","46.1","","","","","","","","","30.53","","","40.98","","","7.88",""
"47","No","Yes","On a regular basis","On a regular basis","","","Clove","Chilli","Cumin","Modulo detection in Clove/Chilli
Concise loop expression in Clove/Cumin
Inlined writes to s in Chilli","The /* format */ annotation in Clove's output
Messy chain of if/else in Cumin/Chilli due to lack of switch detection","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Not copying longer snippets feels more natural and likely closer to the original source.","No","Yes","No","Snippet 2 feels closest to what original source would be and is more 'readable' than Snippet 1. Extracting blocks as functions can get confusing if they reference local variables.","No preference","Snippet 1 (Copying /* Block #10 */)","No preference","No preference","Following control flow in Snippet 2 is difficult and only tolerable in Snippet 1 for the simple return statement.
","No","No","No","Removing gotos in this case causes nothing but pain","Snippet 1 (Copying /* Block #4 */)","No preference","No preference","No preference","I dislike the use of extra variables to denote control flow in Snippet 2, and copying large blocks is undesirable in Snippet 1. 
while() {return} is also terrible decompilation","No","No","No","Like in the previous section, removing gotos leads to worse decompilation results here.","Snippet 2","Both appear to be plausible, but with only 2 possibilities, Snippet 2 is readable enough.","No preference","While Snippet 1 is probably closer to original source code, Snippet 2 is less complicated, so I don't have a strong preference either way","Snippet 1","This is clearly a switch variable and Snippet 1 best reflects that.","Snippet 1","As in the previous example","Snippet 3","Snippet 1","Snippet 2","I like the concise if statement of Snippet 3. The conditions are simple enough that I prefer their conjunction over nested if statements.","Snippet 1","Snippet 2","Snippet 3","Snippet 4","I prefer Snippet 1 and 2, which keep the statements involving the loop variable 'together'.","","3144.17","30.56","","","","892.83","","","","","","","","","","","2.24","","508.77","","","","","","357.13","","","","","","580.54","","","","","","269.59","","","","","","","","","229.89","","","269.63","","","2.99",""
"48","","","More than a year","Several days","","","Chilli","Clove","Cumin","Easy to understand at a look","Too many nested else and if","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Length","No","No","Yes","More clean","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Length","No","No","Yes","More clean","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Length","No","No","Yes","Clean","Snippet 1","Easier to read","Snippet 1","Easier to read","Snippet 1","Easiest to understand the conditions","Snippet 1","Easiest to understand the conditions","Snippet 3","Snippet 1","Snippet 2","Clean","Snippet 3","Snippet 2","Snippet 4","Snippet 1","Simpler to understand","","908.61","31.37","","","","158.49","","","","","","","","","","","4.36","","103.97","","","","","","95.77","","","","","","112.43","","","","","","168.83","","","","","","","","","57.39","","","168.73","","","7.27",""
"50","Yes","No","More than a year","On a regular basis","","","Chilli","Cumin","Clove","Using switch-case instead of nested if statements, as it can get very messy.","Naming of variables like ""local_10"". ","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Code length","No","Yes","Yes","If the code block is to be duplicated, I would prefer it to be either short, or made into a function like Snippet 3.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Code length. Prefer to have less lines of code if the code block is going to be duplicated.","No","Yes","Yes","Prefer not to have duplicated code blocks if there are many lines of code. If there is, would be good to have it in a function like Snippet 3.","No preference","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","Code length for Option 1.
Option 3 is too long with many function calls.","No","Yes","Yes","Snippet 3 will be very clear if the decompiler supports clicking of call_sub to go to the decompiled code of the call_sub function. ","Snippet 2","Easier to understand if there is not too much nested if-else statements.","Snippet 2","Even though it is longer, it is still easy to understand.","Snippet 1","If there are more conditions in the if statements, I prefer the switch-case's default block.","Snippet 1","Same reasoning as above.","Snippet 3","Snippet 2","Snippet 1","For Snippet 1, there are too many conditions and parentheses and the reverse engineer might get lost or read something wrongly due to operator's precedence.

For Snippet 2 and 3, it breaks the condition into smaller chunks and is easier to understand. ","Snippet 2","Snippet 3","Snippet 4","Snippet 1","For Snippet 2, the While Condition is very clear and one needs to only calculate c and check if it is greater than 10.","","2111.59","201.48","","","","314.48","","","","","","","","","","","5.5","","387.18","","","","","","123.8","","","","","","530.74","","","","","","103.36","","","","","","","","","128.76","","","312.51","","","3.78",""
"51","Yes","No","More than a year","On a regular basis","","","Chilli","Cumin","Clove","Readability, switch case statement instead of large nested conditional statements","Unncessary nested ""<"" or "">"" conditions just to check for another if condition for ""=="" , such as the one below
else if ( v11 <= 101 )
              {
                if ( v11 == 100 )
                {
                  *(_WORD *)&s[strlen(s)] = 52;
                }
                else if ( v11 == 11 )","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","When decompiled code is repeated, i tend to refer to the disassembly for the memory address for the instructions. If the code is repeated in the decompiled code, it may get quite confusing if they are pointing to the same memory address.
For a single instruction such as Option 1, it is still manageable, but for Options 2 and 3, not repeating the block may seem tidier and easier to understand","No","No","Yes","Code is more presentable and understandable, compared to snippet 2 where there is a while(true) loop waiting for break conditions. Snippet 3 has a clear exit condition for the while loop.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Multiple exit conditions with break seems more confusing compared to a while loop with a fixed exit condition. But if the repeated block gets too large, not repeating it seems more reasonable","No","No","Yes","Code looks easier to understand with while loop exit condition clearly defined","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","","If there are multiple entry within loops, would prefer snippet 1 to show the possible entries into the block. However, if the block is huge, I would not prefer either snippets, as the block should be modularized into a function on its own.","No","No","Yes","Snippet 3 is the clearest and easiest to understand. The repeated block of code is modularized into a function where multiple entries to the block are labelled function calls.","No preference","Both snippets are straight forward and easy to understand.","Snippet 1","With more if conditions regarding the same variable, a switch-case statement is more readable and neater.","Snippet 1","Snippet 1 looks neater and easier to understand. Snippet 2 looks too confusing with the last condition, especially when dealing with more conditional statements. Likewise for Snippet 3, the nested conditions will look horrible with many conditional statements.","Snippet 1","Snippet 3's nested conditions looks like an eyesore, especially when the blocks of code inside are huge. I will not be able to tell the levels of indentation where my block belongs.
Snippet 2's last condition is a mess, and very confusing.
Snippet 1 is the easiest to understand","Snippet 2","Snippet 1","Snippet 3","Snippet 2 is more readable and easy to understand.
Snippet 1 requires me to understand all the condition at once which can be quite confusing.
Snippet 3 requires me to calculate the conditions before going into the if statement.","Snippet 3","Snippet 2","Snippet 4","Snippet 1","Snippet 3's for loop has an easy to understand (x-y) update statement, although the calculations for x and y are rather confusing
Snippet 2 is a simple one-liner that is also easy to understand
Snippet 4 has a rather intimidating (x - (i >> 32)) update statement, which is made worse when x also has a rather confusing calculation.
Snippet 1 looks the most unpleasant because the update statement is long and confusing.","","3715.35","307.76","","","","608.46","","","","","","","","","","","14.14","","643.55","","","","","","542.91","","","","","","376.61","","","","","","452.38","","","","","","","","","219.67","","","517.47","","","32.4",""
"52","No","No","More than a year","Several days","","","Clove","Chilli","Cumin","Switch statement
Array recognition
Comments mapping variables back to memory locations","undefined8
Having to add offset to pointer and dereference (instead of array access)","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Amount of things to read, only to realise it's a copy
Even if realised, it's still visually irritating, and tedious to manually refactor
With Snippet 1 it's okay but still convenient to have just one","No","Yes","Yes","At least it's still one visual block to read","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","IMO Option 1 and Option 2 is not worth the effort of having to follow Snippet 2?","No","No","Yes","IMO feels the cleanest and easiest to follow?","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","No preference","Option 1 and Option 2: IMO copying is easier than having to follow the entry variable?
Not sure for Option 3","No","No","Yes","Easiest to follow","Snippet 1","Easier to read and list the important values of var?","Snippet 1","Easier to read and list the important values of var?","Snippet 1","Easier to read and list the important values of var?","Snippet 1","Easier to read and list the important values of var?","Snippet 3","Snippet 1","Snippet 2","Snippet 3 seems easiest to follow and know the conditions use distinct variables.
Snippet 1 is ok (for this example), can tell it's ""all or nothing""
Snippet 2 for me, nested ifs are visually hard to read (bracing for nested elses)","Snippet 2","Snippet 1","Snippet 4","Snippet 3","Personally prefer if the loop looks as simple as possible?
For Snippet 2, at least the calculation has its own line
Prefer 1 over 3 and 4, to avoid splitting across multiple lines and adding new variables","","2250.75","31.07","","","","465.72","","","","","","","","","","","4.53","","488.88","","","","","","443.35","","","","","","184.92","","","","","","152.26","","","","","","","","","264.79","","","205.57","","","9.66",""
"53","Yes","Yes","More than a year","More than a year","","","Chilli","Cumin","Clove","I like how chilli looks like a proper source code. However, i do trust a decompiler that does less analysis more.","Nil. I do understand why all the aspects are needed and can be helpful even though they are unintuitive.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","No preference for return instructions. However, i do like decompiled codes to look like proper source code and i feel that most programmers will not have multiple blocks of similar instructions in their source code.","No","No","Yes","Like i said, snippet 3 looks more like a proper source code. Snippet 2 might be more complex but it is still acceptable. Snippet 1 does not look like how a programmer will write his source code.","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","I prefer the simplicity of snippet 2. It is also more understandable.","No","No","Yes","Each of the functions are smaller and much easier to understand.","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Simplicity, ease of understanding","No","No","Yes","It looks like a proper source code. Plus, individual functions are smaller which are easier to analyze.","No preference","No preference. They look the same to me. ","No preference","No preference. They look the same to me. ","Snippet 1","Snippet 2 and 3 does not look right. Another alternative i would prefer is if (var ==1) else if (var == 2) - else()","Snippet 1","Same as my previous explanation","Snippet 1","Snippet 3","Snippet 2","I dislike nested instructions. Snippet 1 and 3 looks cleaner although i would much prefer snippet 1 as it looks more like a proper source code.","Snippet 3","Snippet 2","Snippet 4","Snippet 1","Snippet 1 is simply too complicated. It is easier to understand the loop condition from snippet 3 and 2.","","1337.64","23.51","","","","158.11","","","","","","","","","","","7.66","","257.57","","","","","","312.24","","","","","","173.18","","","","","","211.2","","","","","","","","","68.28","","","94.34","","","31.55",""
"54","No","Yes","Several days","More than a year","","","Chilli","Clove","Cumin","I liked how Chilli was able to recover the switch statement.
Clove, by not assigning the result of strlen(s) to an intermediate variable, was able to produce a decompilation with less visual clutter.","Cumin's decompilation is probably closest to what it looks like in disassembly - a lot of branches. Not very useful though.
Likewise with Clove, but Clove does it much better with a cleaner by using lesser intermediate variables.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","If Block 10 contained interesting operations or needed a more in-depth look, having it in one location lets me focus better.
Usually I like to comment/highlight, having multiple copies just means that I'd need to copy my highlights and comments to duplicate blocks.","No","Yes","Yes","Similar reasons as above, but no real preference between snippet 2 or 3.","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Similar explaination as before - Not Copying makes it easier for analysis.","No","Yes","Yes","As above.","Snippet 2 (Not copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Same reasoning as before. Less duplicated code means less bloat.","No","Yes","Yes","As above.","Snippet 1","I find switch statements slightly easier to read here, but I'm fine with either.","Snippet 1","As above,switch statements slightly easier to read here, but I'm fine with either.","Snippet 1","As above.","Snippet 1","As above.","Snippet 3","Snippet 2","Snippet 1","Snippet 3 is much easier to read compared to the first 2. 
In this case, I might be accessing each of the conditionals separately. Having each of the conditionals as separate intermediate variables lets me rename them accordingly.
I can do something similar in snippet 2 by commenting on each line.
Snippet 1 is the worst because inlined conditionals make it difficult mark which check is doing what.","Snippet 3","Snippet 2","Snippet 4","Snippet 1","Snippet 3 is much easier to process by creating intermediate variables x and y and operating on them within the loop brackets.
Snippet 2 is second, with a similar reason as above.
Snippet 4 is similar to 3, but not as good because it only creates 1 intermediate variable x - think it is better to commit to either having the operation within the loop syntax or not.
Snippet 1 is difficult to analyze because it creates a lot of clutter on the for loop syntax.","","2934.67","30.07","","","","1007.21","","","","","","","","","","","4.05","","425.91","","","","","","144.66","","","","","","119.84","","","","","","207.88","","","","","","","","","288.57","","","696.82","","","9.66",""
"56","No","No","On a regular basis","Several days","","","Cumin","Chilli","Clove","Neatness; able to quickly deduce there are switch statements and the values for each case.","Too many unnecessary casting information","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","The number of lines of code. Prefer larger code blocks to not be copied/repeated as it can make it harder/take longer for users to understand that such code blocks are actually the same.","No","Yes","Yes","Both choices allows me to understand more quickly when a code block will be executed. Better preference for snippet 3 if the extracted code block is relatively large, making the code more modular and easier to understand.","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","For larger code blocks that are copied, it takes more time to realize that both blocks are actually identical and hinders program understanding.","No","Yes","Yes","For more complicated blocks I prefer if it is not copied again or it is extracted into a function for quicker understanding of the code.","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Size of code block. For larger/more complicated blocks I would prefer for it to not be repeated as it makes it harder to realize two code blocks at different parts of the code are actually the same.","No","Yes","Yes","Prefer larger/complicated code blocks to not be repeated across the code for quicker understanding of program behaviour.","Snippet 1","Easier to determine that the case statements depend on the same variable, especially when there are a lot of conditional (case/if-else) statements.","Snippet 1","Easier to determine that the case statements depend on the same variable, especially when there are a lot of conditional (case/if-else) statements.","Snippet 1","I find it easier to understand the conditions under which a code block will be executed when placed within switch-case statements. Having a default case makes it clearer that a specific code block is executed when all other conditions are false.","Snippet 1","I find it easier to understand the conditions under which a code block will be executed when placed within switch-case statements. Having a default case makes it clearer that a specific code block is executed when all other conditions are false. It also avoids too much nesting when there are many possible cases.","Snippet 1","Snippet 3","Snippet 2","Fewer lines of code, especially when there are no else clauses for each of the conditions, are preferred as they help make code more readable and quicker to understand.","Snippet 1","Snippet 2","Snippet 3","Snippet 4","Snippet 1 allows quicker understanding of what the number of rounds in a for loop is dependent on. Snippet 3 is better than snippet 4 as the values for x and y are placed together, allowing for quicker deriving of how variable i is calculated.  ","","3917.12","37.11","","","","590.03","","","","","","","","","","","16.07","","767.02","","","","","","566.01","","","","","","802.33","","","","","","360.55","","","","","","","","","179.31","","","590.82","","","7.87",""
"57","No","No","Several days","None","","","Chilli","Clove","Cumin","Shorter expressions tend to be more easy to read. The switch-case statement appears to be more a lot clearer than the nested branches.","Long expressions (containing cast operations) are more difficult to read. The nested branching is somewhat cluttered and more difficult to follow.","","","","","","","","","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","If the instruction sequence in Block #10 is too long, the overall code appears cluttered and becomes more difficult to read, even though it only contains the same instruction sequence multiple times.","No","No","Yes","Even though Block #10 appears in both Snippet 2 and Snippet 3 only once, Snippet 3 appears to be more readable as it's branching seems to be less complex compared to Snippet 2. Also extracting code which is used at multiple locations into a named function makes it easier to remember what the code sequence actually does.","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","If the instruction sequence is relatively short, copying the sequence into multiple locations appears to be a good trade-off between overall code length and a more complex. The instruction sequence in Option 2 seems to be a good boundary, whereas the seuquence in Option 3 would make Snippet 1 appear more cluttered. ","No","Yes","Yes","Extracting Block #10 into a separate function as in Snippet 3 is the most favorable solution as it enables to decrease the overall code length and the complexity of the code structure.  Snippet 2's structure is more complex than the structure of Snippet 1, but as Block #10 contains a more complex structure, copying the code block into multiple locations would increase the overall complexity of Snippet 1.
","No preference","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","This time the structure of Snippet 1 and Snippet 2 appear to be equally complex. Thus, copying Option 2 could be avoided as it does necessarily bring a less complex structure. Option 3 appears to be too large to be copied into multiple locations compared to the reduced structure complexity that is achieved. ","No","Yes","Yes","Extracting the code into a separate function still is the most readable and least complex solution. However, as the overall complexity of Snippet 2 is somewhat equal to the complexity of Snippet 1,  Snippet 2 seems also OK.","No preference","The Switch-Statement and the If-Statements appear to be equally complex. Thus, no real preference.","No preference","Switch-Statement and If-Statements contain more cases, but the overall structure seems to be equally complex.","Snippet 1","Snippet 3 contains nested branching, which seems to have the most complex structure compared to the other Snippets. Snippet 2 shows the same level of branching as Snippet 2. Actually, there is no real preference between Snippet 1 and Snippet 2, but I stick to Snippet 1 as it handles the ""default"" case in a more elegant way.","Snippet 1","Snippet 3 contains even more nested branches. The expression to handle the ""default"" case in Snippet 2 is too long. The Switch-Statement appears as it has been made for this kind of branching.","Snippet 3","Snippet 2","Snippet 1","","Snippet 1","Snippet 3","Snippet 2","Snippet 4","Snippet 4 appears to be the most intuitive solution as one would expect a for-loop-statement to be (even though the update statement is complex).  Considering that the update statement is complex, Snippet 3 is the next favorable solution: Rather simple update statement, values are determined in the for-loop. Even though Snippet 2 is no for-loop, the while-loop looks like it was written by human beings. Snippet 4 appears to be the least favorable solution as the Update-Statement is a mixture of a value determined in the loop and the former iteration value. This is a mixture of Snippet 1 and Snippet 3.","","6054.06","30.71","","","","932.89","","","","","","","","","","","8.86","","1136.92","","","","","","876.61","","","","","","801.92","","","","","","447.61","","","","","","","","","149.19","","","1652.17","","","17.18",""
"58","Yes","Yes","More than a year","Several days","","","Chilli","Clove","Cumin","switches in place of a huge and nested if-else block makes the decompiled code more readable.","the decompiled functions here are generally okay, except for the nested if-else blocks.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Unless the block is a one-liner that branches, (""return, break, continue, call""), I prefer to not have a block of code copied out.","No","Yes","Yes","Unless the block is a one-liner that branches, (""return, break, continue, call""), I prefer to not have a block of code copied out. Snippet 3 here simplifies the block into a one-liner, which falls into the (""return, break, continue, call"") category. In such cases where a block is ""extracted"" into a function, I think it'll be good to also have a hint that the function does not actually exist.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Similar to the section before.","No","Yes","Yes","Similar to the section before. Note that the ""extracted"" function should have a hint that it is a real function.","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Similar to the section before.","No","Yes","Yes","Similar to the section before.","No preference","No preference if the number of differentiating conditions (2 in this case) are small.","Snippet 1","For larger number of conditions, a switch-block makes the code easier to read over a series of if-blocks.","Snippet 1","In this case, the switch-block makes the decompiled code easier to read. There is no need to run through individual if-statements only to know that Block #3 is the ""default"" case.","Snippet 1","I'm not a fan of nested if-blocks. Switch-blocks are much easier to read in this case, given that the matching condition is a single variable. However, in the event where the if-condition has multiple variables, ""if (a && b || c)"" etc., then it will be difficult to represent the code in switch-blocks. In such cases, if-blocks would be preferred. As mentioned earlier as well, the switch-block is preferred here as it is easy to identify the ""default"" case.","Snippet 3","Snippet 2","Snippet 1","Snippets 3 & 2 are tied. They make reading the conditions necessary to enter the loop easier to interpret.","Snippet 1","Snippet 3","Snippet 2","Snippet 4","Snippet 1 clearly shows the for-loop's continuation and increment conditions. However, if they become too complicated, breaking them down into that shown in Snippet 3 can be handy. However, in Snippet 4, it is neither within the for-loop's brackets nor extracted fully at the end of the loop. This feels half-baked and somewhat confusing to follow. The use of while-loops in Snippet 2 requires the initialization to be done outside and before of it and is least favourable for me.","","2203.89","48.28","","","","375.56","","","","","","","","","","","94.78","","443.91","","","","","","146","","","","","","68.12","","","","","","474.66","","","","","","","","","84.11","","","446.62","","","21.85",""
"59","No","Yes","More than a year","Several days","","","Chilli","Clove","Cumin","Chilli","Cumin","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","","No","Yes","No","","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","","Yes","Yes","Yes","","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","","Yes","No","Yes","","No preference","","No preference","","","","Snippet 1","","Snippet 2","Snippet 3","Snippet 1","","Snippet 3","Snippet 1","Snippet 2","Snippet 4","","","3445.47","372.41","","","","299.48","","","","","","","","","","","5.97","","1803.27","","","","","","170.45","","","","","","422.6","","","","","","82.67","","","","","","","","","130.2","","","153.18","","","5.24",""
"60","Yes","Yes","Several days","Several days","","","Chilli","Cumin","Clove","switch case in chilli","too many indentations","","","","","","","","","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)"," number of instructions. snippet 2 is preferred if there are many instructions","No","Yes","No","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","","No","Yes","Yes","","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","","No","Yes","Yes","","Snippet 1","","Snippet 1","","No preference","","Snippet 1","","Snippet 1","Snippet 2","Snippet 3","","Snippet 3","Snippet 4","Snippet 1","Snippet 2","","","901.87","28.03","","","","140.4","","","","","","","","","","","8.46","","253.14","","","","","","82.94","","","","","","240.9","","","","","","84.65","","","","","","","","","32.61","","","25.11","","","5.63",""
"62","","","More than a year","A few hours","","","Clove","Chilli","Cumin","Especially the 'Chilli' decompiler, produced a clear and easy readable code, which wasn't too nested due to the use of switch-case statements.","Declaration of numerous local variables, which unclear usage. E.g., 'Cumin' defined the following variables:  

undefined8 local_68 undefined8 local_60, undefined8 local_58, undefined8 local_50, undefined8 local_48, undefined8 local_40, undefined8 local_38, undefined8 local_30, undefined , cal_28, long local_18, int local_10 uint local_c.

But from these variables, only a few (= local_68, local_18, local_10, local_c) were actually used in the code above.
This results in cluttered code, with more hard to understand.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","","No","No","Yes","I like snippet 3 the best because it removes the code duplication from snippet 1. Although the function is called twice, it is more readable than snippet 2 because the structure is easier to follow.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","Option 3 is the codes, which shows most explicit what exactly it does. Although it is more lengthy than the other options, it is the code I best understand / can read.
Because, option3 would be for snippet 2 called outside the while statement, it is best, if the intention of the instructions are clear, without the context of the loop.
I chose option1 for the first snipped, because of its simplicity. Especially if the code is called twice and is not wrapped by a function, it is preferable if the code is then simple.","No","Yes","No","Snippet 1 is the snippet which I like the least, because of the code duplication. I prefer the structure of snippet 2 over the wrapping function of snippet 3 because its instructions are less difficult to understand for me.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","I choose option 1 for snippet 1 to reduce the code duplication.
Option 3 is in my opinion better suitable for snippet 2 because the code is more 'expressive', meaning it shows in a meaningful, explicit way what is exactly does, whereas the simple return statement might be unclear, what exactly being returned.","No","No","Yes","I chose snippet 3 because it has the easiest structure without any code duplication. Hence, it is easy to read.","Snippet 1","Although switch case statements might be a little lengthier than the if statements from snippet 2, they have the better and cleaner structure.
In specific, any case refers to the same variable, whereas in the multiple if statements this can be potentially mixed up and therefore difficult to read.
Furthermore, the switch statements encapsulate all cases so that it's obvious, when the parsing ends.","Snippet 1","Same reason as above:

Although switch case statements might be a little lengthier than the if statements from snippet 2, they have the better and cleaner structure.
In specific, any case refers to the same variable, whereas in the multiple if statements this can be potentially mixed up and therefore difficult to read.
Furthermore, the switch statements encapsulate all cases so that it's obvious, when the parsing ends.","Snippet 1","I still prefer snippet 1, because of its structure. Although snippet 3 has a better structure than snippet 2, it might be potentially difficult to read because it gets more and more nested for each additional IF-ELSE block. ","Snippet 1","As already explained above, I like the switch statement the most.
Although snippet 2 is less nested and a bit shorter, snippet 1 is better to read.
Especially the “default” case is clearer than the long IF-statement from snippet 2 at the end (line 17 / 18)","Snippet 1","Snippet 2","Snippet 3","Snippet 1 has a single but very complicated boolean statement, so that is hard to understand.
Snippet 2 is easy to read, but the longer the statement gets, the more nested the function will be.
At some points, very nested function also might be difficult to understand.
I like snippet 3 the most, as it consist only of few, simple boolean functions, which are eventually combined by simple operations (AND).","Snippet 3","Snippet 2","Snippet 4","Snippet 1","Shifting, especially inside the condition of the FOR-loop, is difficult to understand. So, it might be unclear, over which exact elements are iterated.
Therefore, snippet 3 and 2 are the best readable snippets. I prefer snippet 3 over snippet 2 because the iteration step is a bit more clear.
Snippet 1 is the in my opinion the worst as the iteration step consists of multiple complicated statements, including shifts, and is therefore hard to interpret.","Most of the code snippets where very similar. I would suggest to show more different examples. Furthermore, it was unclear what the intention of the code supposed to be. If more context was shown, choosing which option is preferable would be probably easier.","3945.9","15.43","","","","804.06","","","","","","","","","","","3.23","","709.64","","","","","","695.25","","","","","","391.43","","","","","","636.47","","","","","","","","","179.54","","","355.04","","","155.81",""
"63","No","No","More than a year","Several days","","","Chilli","Clove","Cumin","Chilli: The switch case is much easier to read than the nested if/ else/ else if structures.
Chilli and Clove: The instructions before entering the loop where optically clearly distinguishable from the loop.
","Clove: The nested else if statements are hard to read.
Cumin: The nested if statements were not as easy to read as the switch case structure in Chilli. The many variables were a bit confusing.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","I think that in snippet 2 the general structure of the program and how/ when we reach Block #10 is easier to see.","No","Yes","Yes","As above I think not duplicating the snippet makes the program structure easier to see. Extracting it as a function has a similar effect to just using the snippet once.","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","When not copying the snippet, the structure is easier to see.","No","Yes","Yes","When not copying the snippet, the structure is easier to see. Replacing the snippet with a function call also makes this easier, although having the snippet only once is still the easiest.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","The criteria in line 10 and 11 of the second snippet were a bit hard to read, but for a longer block 4, this would be worth not duplicating the long code block.","No","No","Yes","Here in snippet 3 makes getting an overview about the functionality of the code the easiest.","No preference","Here both are equally readable and the if construction is more familiar. But in the first example in the survey with the multiple nesting layers for the (else) if structures, these became quite confusing and the switch case construction would be preferable.","Snippet 1","Again, both are almost equally readable, but the switch case construction shows more clearly that all of the following cases/ if statements will be dependent on the value of this one variable, which gives an overview over the code functionality more quickly.","Snippet 1","I don't think the nested if/ else statements are easy to read. The second snippet is also okay, but line 8 would most likely become less readable for more previous cases7 if statements, so snippet 1 is easiest to read.","Snippet 1","The nested if else statements are really hard to read, especially if there are a lot of them and one has to work on a smaller screen, and line 17 in the second snippet becomes too long. Snippet one is the easiest and fastest to read.","Snippet 2","Snippet 3","Snippet 1","Snippet 1 seems most familiar and easiest at first glance, but the nested parentheses are hard to read. Snippet 2 and 3 are easy to read. While the nested if statements in 2 would probably become harder to read if there were even more of  them,  one only has to read them once when looking through the code, whereas in snippet 3 in line 5 one has to remember the contents of lines 2-4.","Snippet 3","Snippet 1","Snippet 4","Snippet 2","i think the for loop is easier to read in this case. I find splitting up the i update in snippet 4 more confusing than helpful, since now one has to look in 2 places. Either snippet 3 or snippet 1 are fine. While in snippet 1 the functionality of the for loop is more clearly stated in one place, snippet 3 is easier to read. Here the structure, length and content of Block #1 would most likely also influence the readability, i.e. snippet 3 would be less favorable than snippet 1 if block #1 was long and updates to x and y somehow hidden in the block.","","4121.4","96.85","","","","817.52","","","","","","","","","","","7.44","","863.04","","","","","","676.82","","","","","","368.45","","","","","","445.28","","","","","","","","","349.4","","","436.97","","","59.63",""
"64","Yes","Yes","More than a year","On a regular basis","","","Chilli","Clove","Cumin","Clear structure based on the switch allows better comprehension than nested if statements.","given nested if statements beyond degree 2-3, any alternative cases (especially on the same level but lines further down in the code) become hard to follow quickly.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","if repetition is avoidable, that's output I would prefer as it allows to code paths to merge into one point eventually.
If the repetition is comprised of 1,2,3 instructions, that may be helpful, especially if the code path ends there (return) - means potential code paths do not have to be followed mentally anymore.","No","Yes","Yes","Here, snippet 2 merges potential code paths at a point where something relevant is happening (user interaction).
Function extraction (snippet 3) looks just as good to me - as long as it is clearly stated that the output has been optimized for comprehension and is not as close to its disassembly source/structure.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","I think I already had this question?
Anyhow, short code copied (1,2,3 instructions) is fine, for longer instruction sequences, merging flow is preferred.","No","Yes","Yes","same arguments as before, relevant functionality happening after code flow is merged is nice and function extraction is fine as well.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","overall, I like snippet one more because it has simpler conditional expressions.
but once again, if the copied code portion becomes too long, I'd rather have it once during a time of mostly non-conditional, linear code flow.","No","No","Yes","given my previous arguments, snippet 3 is best of both worlds. ","Snippet 1","I'd say this depends on the length of block #1 and #2, which is not shown.
Otherwise I probably like snippet 1 more because the switch can be understood as one big coherent block, while I would have to check in snippet 2 if var is modified in a way that would lead to execution of block #2.","Snippet 1","for the same reason that the break statements in snippet 1 suggest a single case being taken at most, this is easier to follow than snippet 2 which may have code in the blocks that may lead to execution of more than one if-body.","Snippet 1","snippet 1 with the same arguments as above (easy to follow thanks to the breaks) and otherwise snippet 3 over snippet 2 if the nesting remains on this level.","Snippet 1","switch is preferred in this structure. 
snippet 2 is at least more flat and indentation is really painful once those single-line ""block #n"" have several instructions.","Snippet 2","Snippet 3","Snippet 1","Thinking about visual flow, snippet 3 has the best presentation of the conditions, while snippet 2 at least breaks them also down on individual lines.","Snippet 2","Snippet 1","Snippet 3","Snippet 4","if I see ""for"" my first thought is some action repeated in a sequence for <n> times.
While on the other hand implies a repetition for as long as a condition is met.
That makes snippet 2 feel more natural here.
Snippet 1 at least keeps the condition out of the body, 3+4 are a mix where need to read and think about too many lines to understand what and why this condition is updated.","good luck on the paper submission! :)","1928.34","17.08","","","","235.82","","","","","","","","","","","8.98","","345.44","","","","","","155.32","","","","","","247.3","","","","","","397.72","","","","","","","","","151.22","","","334.34","","","35.12",""
"78","No","No","Several days","Several days","","","Chilli","Clove","Cumin","easy to follow along structure","too many if else conditions","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","option 3 is too lengthy","No","No","Yes","cleaner structure and easier to understand. can simply go through the function once to understand the operations involved.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","too lengthy","No","No","Yes","easier to follow as the code is structured","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","length of the block","No","Yes","Yes","shorter code and easy to follow structure","No preference","similar in length and both snippets are still easy to comprehend","No preference","similar in length and both snippets are still easy to comprehend","Snippet 1","easier to follow","Snippet 1","the other two snippets have too much conditions and if-else statements","Snippet 2","Snippet 3","Snippet 1","having all the conditions in one line is too much","Snippet 3","Snippet 4","Snippet 2","Snippet 1","having too much calculations at the for loop makes the code harder to follow","","2122.08","56.7","","","","386.18","","","","","","","","","","","119.25","","746.5","","","","","","264.88","","","","","","177.06","","","","","","139.78","","","","","","","","","137.37","","","86.61","","","7.75",""
"79","No","No","Several days","Several days","","","Chilli","Clove","Cumin","The use of switch case from Chili makes the code cleaner and readable.","Too many if else statements from Cumin which makes the whole code messy and harder to read & understand.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","I feel that a longer instruction if possible should not be repeated but only once while a shorter instruction can be repeated to simplify the code structure","No","Yes","Yes","I would prefer snippet 2 more because of non repeated codes but snippet 3 is also fine if repeat is necessary as making it into a function tidies up the structure.","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Would prefer codes not to be repeated but if necessary then the shorter instructions could be repeated","No","Yes","Yes","Snippet 2 & 3 makes the code looks tidier as there are no repeats of code compared to snippet 1.","Snippet 1 (Copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","As the codes in snippet 1 is shorter than snippet 2, option 1 being repeated is fine but if the instructions are long, then snippet 2 will be easier to read","No","Yes","Yes","Snippet 2 & 3 looks cleaner & readable than snippet 1","Snippet 1","Looks cleaner & condition only validate once","Snippet 1","Looks cleaner & condition only validate once","Snippet 1","Looks cleaner & condition only validate once","Snippet 1","Looks cleaner, condition only validate once & code more understandable","Snippet 3","Snippet 2","Snippet 1","Snippet 3 looks cleaner without the nested if else compared to snippet 2 & easier to evaluate compared to snippet 1","Snippet 3","Snippet 4","Snippet 2","Snippet 1","It's easier to understand if the condition is modified outside of the loop rather than putting it all in one line","","2020.22","59.9","","","","224.9","","","","","","","","","","","4.57","","806.33","","","","","","281.94","","","","","","201.96","","","","","","157.93","","","","","","","","","75.47","","","200.91","","","6.31",""
"80","No","No","On a regular basis","On a regular basis","","","Chilli","Clove","Cumin","deeply nested code is hard to read, hence I enjoyed the one with switch. Apart from that arithmetic was displayed a litter bit better in Chilli than Clove.","lots of redundant local variables","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","duplicate code can lead to reading the same things twice even though it's doing the same. So if a decompiled decides to duplicate code, it should only do so for portions that one can be understood very fast.","No","Yes","No","Especially for a very simple case like this (only called ones, instead of `/*logic*/ return var;` it is just `return foo(); int foo() /* logic */`), hat the decompiler should imho not create artificial functions.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","same as before","No","No","Yes","Snippet 1 duplicates a lot of code, so absolutely not an option. Snipped 2 needs to use the helper variables to avoid the duplication, which adds cognitive load, hence Snippet 3 is preferable.","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","same as before","No","No","Yes","same as before","Snippet 1","switch cases are a great way to express the connected-ness of branches, hence I prefer it.","Snippet 1","same as above","Snippet 1","same as above","Snippet 1","wow, same as before!","Snippet 3","Snippet 1","Snippet 2","Snippet 3 is very easy to read and I have the opportunity to rename the three `cond` variables, hence it's ranked highest. Snippet 2 is deeply nested just for the sake of a logical and, hence I prefer Snippet 1 over it even though Snippet 1 has a hard-to-parse arithmetic expression (it was a close call between 1 and 2, both are relatively hard to read).","Snippet 4","Snippet 3","Snippet 1","Snippet 2","for loops can transport a lot more meaning by basically deciding that a certain variable is a counter. Hence I prefer snippets with for loops over the one with the while loop. I ranked the for-loop snippets by how well the decompiler as able to distinguish in-loop calculations from progression-step calculations: Snippet 4 looks the cleanest there.","very interesting survey, made me think about my preferences and why I have them!","1112.4","34.93","","","","165.52","","","","","","","","","","","7.86","","236.43","","","","","","230.99","","","","","","71.99","","","","","","71","","","","","","","","","129.66","","","138.32","","","25.7",""
"82","","","A few hours","More than a year","","","Chilli","Clove","Cumin","presenting as case, instead of massive loops. Showing the logic of the loop condition.","Cumin view, logic flow difficult to understand at first glance.","","","","","","","","","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Length of code.","No","No","Yes","Fewer lines of code.","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","","No","No","Yes","Fewer line of code.","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","","No","No","Yes","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 1","","Snippet 3","Snippet 2","Snippet 1","Snippet 3 is easier to read.","Snippet 3","Snippet 4","Snippet 2","Snippet 1","","","1032.66","55.33","","","","395.64","","","","","","","","","","","11.49","","272.82","","","","","","80.06","","","","","","35.39","","","","","","36.34","","","","","","","","","61.8","","","77.48","","","6.31",""
"84","Yes","Yes","A few hours","More than a year","","","Chilli","Clove","Cumin","more human readable, closer to high-level programming code","unnecessary casting and convoluted computation","","","","","","","","","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","preference to avoid repeated codes blocks, even if it is 5 lines.","No","No","Yes","neater and avoids repeated code blocks","No preference","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","preference for not reading code blocks that are identical.","No","No","Yes","neater and easier to understand.","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","Snippet 2 (Not copying /* Block #4 */)","for 1-liners, it is ok to duplicate the instructions. otherwise, it is preferred for identical code blocks (functionality) to be called once.","No","No","Yes","neater and easier to read.","No preference","if..else for switch case is easily readable, no difference.","No preference","if..else for switch case is easily readable, no difference.","No preference","all snippets are still readable. no preference so long as the conditional statements are straight forward .","No preference","all snippets are still readable. no preference so long as the conditional statements are straight forward .","Snippet 3","Snippet 2","Snippet 1","makes it easier to follow conditions","Snippet 1","Snippet 3","Snippet 2","Snippet 4","no exact preference between snippet 1 and 3 as they are the same and easy to distinguish the conditions and the instructions after the loop.
snippet 4 makes it easy to make mistakes by splitting the instructions between the code block and the for end-loop","great piece of work! look forward to using it to analyze codes","2706.61","43.58","","","","223.4","","","","","","","","","","","15.14","","751.77","","","","","","537.15","","","","","","131.4","","","","","","447.3","","","","","","","","","146.32","","","379.18","","","31.37",""
"85","Yes","No","More than a year","More than a year","","","Chilli","Clove","Cumin","Switch statements are easier to comprehend compared to if-else","Too many layers of nested blocks of code.","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","No preference","No preference","Snippet 2 (Not copying /* Block #10 */)","More complex the code block should not be duplicated.
","No","Yes","No","The criteria to enter the Block #10 only occurs at 1 place..","Snippet 2 (Not copying /* Block #10 */)","No preference","No preference","Snippet 2 (Not copying /* Block #10 */)","complex code should only be evaluated once or minimally.","No","Yes","No","Criteria to enter into Block #10 is only evaluated once.","Snippet 2 (Not copying /* Block #4 */)","No preference","No preference","Snippet 2 (Not copying /* Block #4 */)","Complex code should be evaluated once or minimally.","No","Yes","No","The conditions leading to Block#4 is processed prior to the call.","Snippet 1","Switch statement contains less visual artefacts (it's neater)","Snippet 1","Switch statement contains less visual artefacts (it's neater)","Snippet 1","It is more succinct.","Snippet 1","It is more succinct.","Snippet 3","Snippet 1","Snippet 2","They are ranked in order of clarity of the conditions.  Nested if-else are hard to read.","Snippet 4","Snippet 1","Snippet 2","Snippet 3","Conditions of the loop are not diluted within the loop.","","2539.44","134.51","","","","447.5","","","","","","","","","","","21.13","","769.02","","","","","","143.58","","","","","","376.51","","","","","","251.21","","","","","","","","","206.43","","","180.73","","","8.82",""
"86","No","No","Several days","More than a year","","","Chilli","Clove","Cumin","switch case","","","","","","","","","","Snippet 2 (Not copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","Snippet 2 (Not copying /* Block #10 */)","No preference","","No","Yes","Yes","first snippet increases cognitive load while trying to match both blocks
third snippet could distract me from code comprehension in terms of existent functions (which are present in real in binary) and virtual (which introduced by decompiler)","Snippet 1 (Copying /* Block #10 */)","Snippet 1 (Copying /* Block #10 */)","No preference","Snippet 2 (Not copying /* Block #10 */)","","No","Yes","No","","Snippet 2 (Not copying /* Block #4 */)","Snippet 1 (Copying /* Block #4 */)","No preference","Snippet 2 (Not copying /* Block #4 */)","","No","Yes","Yes","","Snippet 1","in short switch case while `switch(var)` is visible it's good to have snippet one
","Snippet 2","in case when lot of blocks it's good to see `var == x`","Snippet 1","","Snippet 1","","Snippet 3","Snippet 2","Snippet 1","","Snippet 2","","","","","","1369.88","34.22","","","","187.88","","","","","","","","","","","13.64","","263.05","","","","","","168.63","","","","","","176.15","","","","","","244.72","","","","","","","","","150.71","","","119.27","","","11.61",""

